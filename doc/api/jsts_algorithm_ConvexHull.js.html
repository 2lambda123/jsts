<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/algorithm/ConvexHull.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/algorithm/ConvexHull.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/algorithm/CGAlgorithms.js
   * @requires jsts/util/UniqueCoordinateArrayFilter.js
   * @requires jsts/util/Assert.js
   */

  var CGAlgorithms = jsts.algorithm.CGAlgorithms;
  var UniqueCoordinateArrayFilter = jsts.util.UniqueCoordinateArrayFilter;
  var Assert = jsts.util.Assert;
  var Stack = javascript.util.Stack;
  var ArrayList = javascript.util.ArrayList;
  var Arrays = javascript.util.Arrays;

  /**
   * Compares {@link Coordinate}s for their angle and distance relative to an
   * origin.
   *
   * @private
   */
  var RadialComparator = function(origin) {
    this.origin = origin;
  };

  RadialComparator.prototype.origin = null;

  RadialComparator.prototype.compare = function(o1, o2) {
    var p1 = o1;
    var p2 = o2;
    return RadialComparator.polarCompare(this.origin, p1, p2);
  };

  /**
   * Given two points p and q compare them with respect to their radial ordering
   * about point o. First checks radial ordering. If points are collinear, the
   * comparison is based on their distance to the origin.
   * &lt;p>
   * p &lt; q iff
   * &lt;ul>
   * &lt;li>ang(o-p) &lt; ang(o-q) (e.g. o-p-q is CCW)
   * &lt;li>or ang(o-p) == ang(o-q) &amp;&amp; dist(o,p) &lt; dist(o,q)
   * &lt;/ul>
   *
   * @param o
   *          the origin.
   * @param p
   *          a point.
   * @param q
   *          another point.
   * @return -1, 0 or 1 depending on whether p is less than, equal to or greater
   *         than q.
   */
  RadialComparator.polarCompare = function(o, p, q) {
    var dxp = p.x - o.x;
    var dyp = p.y - o.y;
    var dxq = q.x - o.x;
    var dyq = q.y - o.y;

    var orient = CGAlgorithms.computeOrientation(o, p, q);

    if (orient == CGAlgorithms.COUNTERCLOCKWISE)
      return 1;
    if (orient == CGAlgorithms.CLOCKWISE)
      return -1;

    // points are collinear - check distance
    var op = dxp * dxp + dyp * dyp;
    var oq = dxq * dxq + dyq * dyq;
    if (op &lt; oq) {
      return -1;
    }
    if (op > oq) {
      return 1;
    }
    return 0;
  };

  /**
   * Computes the convex hull of a {@link Geometry}. The convex hull is the
   * smallest convex Geometry that contains all the points in the input
   * Geometry.
   * &lt;p>
   * Uses the Graham Scan algorithm.
   *
   * @constructor
   */
  jsts.algorithm.ConvexHull = function() {
    if (arguments.length === 1) {
      var geometry = arguments[0];

      this.inputPts = jsts.algorithm.ConvexHull.extractCoordinates(geometry);
      this.geomFactory = geometry.getFactory();
    } else {
      this.pts = arguments[0];
      this.geomFactory = arguments[1];
    }
  };
  jsts.algorithm.ConvexHull.prototype.geomFactory = null;
  jsts.algorithm.ConvexHull.prototype.inputPts = null;

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.extractCoordinates = function(geom) {
    var filter = new UniqueCoordinateArrayFilter();
    geom.apply(filter);
    return filter.getCoordinates();
  };

  /**
   * Returns a {@link Geometry} that represents the convex hull of the input
   * geometry. The returned geometry contains the minimal number of points
   * needed to represent the convex hull. In particular, no more than two
   * consecutive points will be collinear.
   *
   * @return if the convex hull contains 3 or more points, a {@link Polygon} ; 2
   *         points, a {@link LineString}; 1 point, a {@link Point}; 0 points,
   *         an empty {@link GeometryCollection}.
   */
  jsts.algorithm.ConvexHull.prototype.getConvexHull = function() {

    if (this.inputPts.length == 0) {
      return this.geomFactory.createGeometryCollection(null);
    }
    if (this.inputPts.length == 1) {
      return this.geomFactory.createPoint(this.inputPts[0]);
    }
    if (this.inputPts.length == 2) {
      return this.geomFactory.createLineString(this.inputPts);
    }

    var reducedPts = this.inputPts;
    // use heuristic to reduce points, if large
    if (this.inputPts.length > 50) {
      reducedPts = this.reduce(this.inputPts);
    }
    // sort points for Graham scan.
    var sortedPts = this.preSort(reducedPts);

    // Use Graham scan to find convex hull.
    var cHS = this.grahamScan(sortedPts);

    // Convert stack to an array.
    var cH = cHS.toArray();

    // Convert array to appropriate output geometry.
    return this.lineOrPolygon(cH);
  };


  /**
   * Uses a heuristic to reduce the number of points scanned to compute the
   * hull. The heuristic is to find a polygon guaranteed to be in (or on) the
   * hull, and eliminate all points inside it. A quadrilateral defined by the
   * extremal points in the four orthogonal directions can be used, but even
   * more inclusive is to use an octilateral defined by the points in the 8
   * cardinal directions.
   * &lt;p>
   * Note that even if the method used to determine the polygon vertices is not
   * 100% robust, this does not affect the robustness of the convex hull.
   * &lt;p>
   * To satisfy the requirements of the Graham Scan algorithm, the returned
   * array has at least 3 entries.
   *
   * @param pts
   *          the points to reduce.
   * @return the reduced list of points (at least 3).
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.reduce = function(inputPts) {
    var polyPts = this.computeOctRing(inputPts);

    // unable to compute interior polygon for some reason
    if (polyPts == null)
      return this.inputPts;

    // add points defining polygon
    var reducedSet = new javascript.util.TreeSet();
    for (var i = 0; i &lt; polyPts.length; i++) {
      reducedSet.add(polyPts[i]);
    }
    /**
     * Add all unique points not in the interior poly.
     * CGAlgorithms.isPointInRing is not defined for points actually on the
     * ring, but this doesn't matter since the points of the interior polygon
     * are forced to be in the reduced set.
     */
    for (var i = 0; i &lt; inputPts.length; i++) {
      if (!CGAlgorithms.isPointInRing(inputPts[i], polyPts)) {
        reducedSet.add(inputPts[i]);
      }
    }
    var reducedPts = reducedSet.toArray();

    // ensure that computed array has at least 3 points (not necessarily unique)
    if (reducedPts.length &lt; 3)
      return this.padArray3(reducedPts);
    return reducedPts;
  };

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.padArray3 = function(pts) {
    var pad = [];
    for (var i = 0; i &lt; pad.length; i++) {
      if (i &lt; pts.length) {
        pad[i] = pts[i];
      } else
        pad[i] = pts[0];
    }
    return pad;
  };

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.preSort = function(pts) {
    var t;

    // find the lowest point in the set. If two or more points have
    // the same minimum y coordinate choose the one with the minimu x.
    // This focal point is put in array location pts[0].
    for (var i = 1; i &lt; pts.length; i++) {
      if ((pts[i].y &lt; pts[0].y) ||
          ((pts[i].y == pts[0].y) &amp;&amp; (pts[i].x &lt; pts[0].x))) {
        t = pts[0];
        pts[0] = pts[i];
        pts[i] = t;
      }
    }

    // sort the points radially around the focal point.
    Arrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));

    return pts;
  };

  /**
   * Uses the Graham Scan algorithm to compute the convex hull vertices.
   *
   * @param c
   *          a list of points, with at least 3 entries.
   * @return a Stack containing the ordered points of the convex hull ring.
   */
  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.grahamScan = function(c) {
    var p;
    var ps = new Stack();
    p = ps.push(c[0]);
    p = ps.push(c[1]);
    p = ps.push(c[2]);
    for (var i = 3; i &lt; c.length; i++) {
      p = ps.pop();
      // check for empty stack to guard against robustness problems
      while (!ps.empty() &amp;&amp;
          CGAlgorithms.computeOrientation(ps.peek(), p, c[i]) > 0) {
        p = ps.pop();
      }
      p = ps.push(p);
      p = ps.push(c[i]);
    }
    p = ps.push(c[0]);
    return ps;
  };

  /**
   * @return whether the three coordinates are collinear and c2 lies between c1
   *         and c3 inclusive.
   *
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.isBetween = function(c1, c2, c3) {
    if (CGAlgorithms.computeOrientation(c1, c2, c3) !== 0) {
      return false;
    }
    if (c1.x != c3.x) {
      if (c1.x &lt;= c2.x &amp;&amp; c2.x &lt;= c3.x) {
        return true;
      }
      if (c3.x &lt;= c2.x &amp;&amp; c2.x &lt;= c1.x) {
        return true;
      }
    }
    if (c1.y != c3.y) {
      if (c1.y &lt;= c2.y &amp;&amp; c2.y &lt;= c3.y) {
        return true;
      }
      if (c3.y &lt;= c2.y &amp;&amp; c2.y &lt;= c1.y) {
        return true;
      }
    }
    return false;
  };

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.computeOctRing = function(inputPts) {
    var octPts = this.computeOctPts(inputPts);
    var coordList = new jsts.geom.CoordinateList();
    coordList.add(octPts, false);

    // points must all lie in a line
    if (coordList.size() &lt; 3) {
      return null;
    }
    coordList.closeRing();
    return coordList.toCoordinateArray();
  };

  /**
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.computeOctPts = function(inputPts) {
    var pts = [];
    for (var j = 0; j &lt; 8; j++) {
      pts[j] = inputPts[0];
    }
    for (var i = 1; i &lt; inputPts.length; i++) {
      if (inputPts[i].x &lt; pts[0].x) {
        pts[0] = inputPts[i];
      }
      if (inputPts[i].x - inputPts[i].y &lt; pts[1].x - pts[1].y) {
        pts[1] = inputPts[i];
      }
      if (inputPts[i].y > pts[2].y) {
        pts[2] = inputPts[i];
      }
      if (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {
        pts[3] = inputPts[i];
      }
      if (inputPts[i].x > pts[4].x) {
        pts[4] = inputPts[i];
      }
      if (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {
        pts[5] = inputPts[i];
      }
      if (inputPts[i].y &lt; pts[6].y) {
        pts[6] = inputPts[i];
      }
      if (inputPts[i].x + inputPts[i].y &lt; pts[7].x + pts[7].y) {
        pts[7] = inputPts[i];
      }
    }
    return pts;

  };


  /**
   * @param vertices
   *          the vertices of a linear ring, which may or may not be flattened
   *          (i.e. vertices collinear).
   * @return a 2-vertex &lt;code>LineString&lt;/code> if the vertices are collinear;
   *         otherwise, a &lt;code>Polygon&lt;/code> with unnecessary (collinear)
   *         vertices removed.
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.lineOrPolygon = function(coordinates) {
    coordinates = this.cleanRing(coordinates);
    if (coordinates.length == 3) {
      return this.geomFactory
          .createLineString([coordinates[0], coordinates[1]]);
    }
    var linearRing = this.geomFactory.createLinearRing(coordinates);
    return this.geomFactory.createPolygon(linearRing, null);
  };

  /**
   * @param vertices
   *          the vertices of a linear ring, which may or may not be flattened
   *          (i.e. vertices collinear).
   * @return the coordinates with unnecessary (collinear) vertices removed.
   * @private
   */
  jsts.algorithm.ConvexHull.prototype.cleanRing = function(original) {
    Assert.equals(original[0], original[original.length - 1]);
    var cleanedRing = new ArrayList();
    var previousDistinctCoordinate = null;
    for (var i = 0; i &lt;= original.length - 2; i++) {
      var currentCoordinate = original[i];
      var nextCoordinate = original[i + 1];
      if (currentCoordinate.equals(nextCoordinate)) {
        continue;
      }
      if (previousDistinctCoordinate != null &amp;&amp;
          this.isBetween(previousDistinctCoordinate, currentCoordinate,
              nextCoordinate)) {
        continue;
      }
      cleanedRing.add(currentCoordinate);
      previousDistinctCoordinate = currentCoordinate;
    }
    cleanedRing.add(original[original.length - 1]);
    var cleanedRingCoordinates = [];
    return cleanedRing.toArray(cleanedRingCoordinates);
  };

})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

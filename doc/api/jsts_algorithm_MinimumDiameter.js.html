<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/algorithm/MinimumDiameter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/algorithm/MinimumDiameter.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * @requires jsts/geom/Geometry.js
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/geom/LineSegment.js
 * @requires jsts/geom/Polygon.js
 * @requires jsts/algorithm/ConvexHull.js
 */

/**
 * Computes the minimum diameter of a {@link Geometry}.
 * The minimum diameter is defined to be the
 * width of the smallest band that
 * contains the geometry,
 * where a band is a strip of the plane defined
 * by two parallel lines.
 * This can be thought of as the smallest hole that the geometry can be
 * moved through, with a single rotation.
 * &lt;p>
 * The first step in the algorithm is computing the convex hull of the Geometry.
 * If the input Geometry is known to be convex, a hint can be supplied to
 * avoid this computation.
 * &lt;p>
 * This class can also be used to compute a line segment representing 
 * the minimum diameter, the supporting line segment of the minimum diameter,
 * and a minimum rectangle enclosing the input geometry.
 * This rectangle will
 * have width equal to the minimum diameter, and have one side
 * parallel to the supporting segment.
 *
 * @see ConvexHull
 *
 * @version 1.7
 *
 * @constructor
 */
jsts.algorithm.MinimumDiameter = function (inputGeom, isConvex) {

    /**
     * @type {jsts.geom.Coordinate[]}
     * @private
     */
    this.convexHullPts = null;

    /**
     * @type {jsts.geom.LineSegment}
     * @private
     */
    this.minBaseSeg = new jsts.geom.LineSegment();

    /**
     * @type {jsts.geom.Coordinate}
     * @private
     */
    this.minWidthPt = null;

    /**
     * @type {number}
     * @private
     */
    this.minPtIndex = 0;

    /**
     * @type {number}
     * @private
     */
    this.minWidth = 0;


    jsts.algorithm.MinimumDiameter.inputGeom = inputGeom;
    jsts.algorithm.MinimumDiameter.isConvex = isConvex || false;
};

/**
 * A Geometry which is convex
 * @type {jsts.geom.Geometry}
 * @private
 */
jsts.algorithm.MinimumDiameter.inputGeom = null;

/**
 * &lt;code>true&lt;/code> if the input geometry is convex
 * @type {boolean}
 * @private
 */
jsts.algorithm.MinimumDiameter.isConvex = false;

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @param {number} index
 * @return {number}
 * @private
 */
jsts.algorithm.MinimumDiameter.nextIndex = function (pts, index) {
    index++;
    if (index >= pts.length) {
        index = 0;
    }
    return index;
};

/**
 * @param {number} a
 * @param {number} b
 * @param {jsts.geom.Coordinate} p
 * @return {number}
 * @private
 */
jsts.algorithm.MinimumDiameter.computeC = function (a, b, p) {
    return a * p.y - b * p.x;
};

/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {jsts.geom.LineSegment}
 * @private
 */
jsts.algorithm.MinimumDiameter.computeSegmentForLine = function (a, b, c) {
    var p0;
    var p1;
    /*
     * Line eqn is ax + by = c
     * Slope is a/b.
     * If slope is steep, use y values as the inputs
     */
    if (Math.abs(b) > Math.abs(a)) {
        p0 = new jsts.geom.Coordinate(0, c / b);
        p1 = new jsts.geom.Coordinate(1, c / b - a / b);
    }
    else {
        p0 = new jsts.geom.Coordinate(c / a, 0);
        p1 = new jsts.geom.Coordinate(c / a - b / a, 1);
    }
    return new jsts.geom.LineSegment(p0, p1);
};

/**
 * Gets the length of the minimum diameter of the input Geometry
 * @return {number} the length of the minimum diameter
 */
jsts.algorithm.MinimumDiameter.prototype.getLength = function () {
    this.computeMinimumDiameter();
    return this.minWidth;
};

/**
 * Gets the {@link Coordinate} forming one end of the minimum diameter
 * @return {jsts.geom.Coordinate} a coordinate forming one end of the minimum diameter
 */
jsts.algorithm.MinimumDiameter.prototype.getWidthCoordinate = function () {
    this.computeMinimumDiameter();
    return this.minWidthPt;
};

/**
 * Gets the segment forming the base of the minimum diameter
 * @return {jsts.geom.LineString} the segment forming the base of the minimum diameter
 */
jsts.algorithm.MinimumDiameter.prototype.getSupportingSegment = function () {
    this.computeMinimumDiameter();
    var coord = [this.minBaseSeg.p0, this.minBaseSeg.p1];
    return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString(coord);
};

/**
 * Gets a {@link LineString} which is a minimum diameter
 * @return {jsts.geom.LineString} a {@link LineString} which is a minimum diameter
 */
jsts.algorithm.MinimumDiameter.prototype.getDiameter = function () {
    this.computeMinimumDiameter();

    // return empty linestring if no minimum width calculated
    if (this.minWidthPt === null) {
        return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString(null);
    }

    var basePt = this.minBaseSeg.project(this.minWidthPt);
    return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLineString([basePt, this.minWidthPt]);
};

/**
 * @private
 */
jsts.algorithm.MinimumDiameter.prototype.computeMinimumDiameter = function () {
    // check if computation is cached
    if (this.minWidthPt !== null) {
        return;
    }

    if (jsts.algorithm.MinimumDiameter.isConvex)
        this.computeWidthConvex(jsts.algorithm.MinimumDiameter.inputGeom);
    else {
        var convexGeom = new jsts.algorithm.ConvexHull(jsts.algorithm.MinimumDiameter.inputGeom).getConvexHull();
        this.computeWidthConvex(convexGeom);
    }
};

/**
 * @param {jsts.geom.Geometry} convexGeom
 * @private
 */
jsts.algorithm.MinimumDiameter.prototype.computeWidthConvex = function (convexGeom) {
    if (convexGeom instanceof jsts.geom.Polygon) {
        this.convexHullPts = convexGeom.getExteriorRing().getCoordinates();
    } else {
        this.convexHullPts = convexGeom.getCoordinates();
    }

    // special cases for lines or points or degenerate rings
    if (this.convexHullPts.length === 0) {
        this.minWidth = 0;
        this.minWidthPt = null;
        this.minBaseSeg = null;
    } else if (this.convexHullPts.length === 1) {
        this.minWidth = 0;
        this.minWidthPt = this.convexHullPts[0];
        this.minBaseSeg.p0 = this.convexHullPts[0];
        this.minBaseSeg.p1 = this.convexHullPts[0];
    } else if (this.convexHullPts.length === 2 || this.convexHullPts.length === 3) {
        this.minWidth = 0;
        this.minWidthPt = this.convexHullPts[0];
        this.minBaseSeg.p0 = this.convexHullPts[0];
        this.minBaseSeg.p1 = this.convexHullPts[1];
    } else {
        this.computeConvexRingMinDiameter(this.convexHullPts);
    }
};

/**
 * Compute the width information for a ring of {@link Coordinate}s.
 * Leaves the width information in the instance variables.
 * @param {jsts.geom.Coordinate[]} pts
 * @private
 */
jsts.algorithm.MinimumDiameter.prototype.computeConvexRingMinDiameter = function (pts) {
    // for each segment in the ring
    this.minWidth = Number.MAX_VALUE;
    var currMaxIndex = 1;

    var seg = new jsts.geom.LineSegment();
    // compute the max distance for all segments in the ring, and pick the minimum
    for (var i = 0; i &lt; pts.length - 1; i++) {
        seg.p0 = pts[i];
        seg.p1 = pts[i + 1];
        currMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);
    }
};

/**
 * @param {jsts.geom.Coordinate[]} pts
 * @param {jsts.geom.LineSegment} seg
 * @param {number} startIndex
 * @return {number}
 * @private
 */
jsts.algorithm.MinimumDiameter.prototype.findMaxPerpDistance = function (pts, seg, startIndex) {
    var maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);
    var nextPerpDistance = maxPerpDistance;
    var maxIndex = startIndex;
    var nextIndex = maxIndex;
    while (nextPerpDistance >= maxPerpDistance) {
        maxPerpDistance = nextPerpDistance;
        maxIndex = nextIndex;

        nextIndex = jsts.algorithm.MinimumDiameter.nextIndex(pts, maxIndex);
        nextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);
    }
    // found maximum width for this segment - update global min dist if appropriate
    if (maxPerpDistance &lt; this.minWidth) {
        this.minPtIndex = maxIndex;
        this.minWidth = maxPerpDistance;
        this.minWidthPt = pts[this.minPtIndex];
        this.minBaseSeg = new jsts.geom.LineSegment(seg);
    }
    return maxIndex;
};

/**
 * Gets the minimum rectangular {@link Polygon} which encloses the input geometry.
 * The rectangle has width equal to the minimum diameter, 
 * and a longer length.
 * If the convex hull of the input is degenerate (a line or point)
 * a {@link LineString} or {@link Point} is returned.
 * &lt;p>
 * The minimum rectangle can be used as an extremely generalized representation
 * for the given geometry.
 * 
 * @return {jsts.geom.Geometry} the minimum rectangle enclosing the input (or a line or point if degenerate)
 */
jsts.algorithm.MinimumDiameter.prototype.getMinimumRectangle = function () {
    this.computeMinimumDiameter();

    // check if minimum rectangle is degenerate (a point or line segment)
    if (this.minWidth === 0) {
        if (this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)) {
            return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createPoint(this.minBaseSeg.p0);
        }
        return this.minBaseSeg.toGeometry(jsts.algorithm.MinimumDiameter.inputGeom.getFactory());
    }

    // deltas for the base segment of the minimum diameter
    var dx = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x;
    var dy = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y;

    var minPara = Number.MAX_VALUE;
    var maxPara = -Number.MAX_VALUE;
    var minPerp = Number.MAX_VALUE;
    var maxPerp = -Number.MAX_VALUE;

    // compute maxima and minima of lines parallel and perpendicular to base segment
    for (var i = 0; i &lt; this.convexHullPts.length; i++) {

        var paraC = jsts.algorithm.MinimumDiameter.computeC(dx, dy, this.convexHullPts[i]);
        if (paraC > maxPara) maxPara = paraC;
        if (paraC &lt; minPara) minPara = paraC;

        var perpC = jsts.algorithm.MinimumDiameter.computeC(-dy, dx, this.convexHullPts[i]);
        if (perpC > maxPerp) maxPerp = perpC;
        if (perpC &lt; minPerp) minPerp = perpC;
    }

    // compute lines along edges of minimum rectangle
    var maxPerpLine = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);
    var minPerpLine = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);
    var maxParaLine = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);
    var minParaLine = jsts.algorithm.MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);

    // compute vertices of rectangle (where the para/perp max &amp; min lines intersect)
    var p0 = maxParaLine.lineIntersection(maxPerpLine);
    var p1 = minParaLine.lineIntersection(maxPerpLine);
    var p2 = minParaLine.lineIntersection(minPerpLine);
    var p3 = maxParaLine.lineIntersection(minPerpLine);

    var shell = jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createLinearRing(
        [p0, p1, p2, p3, p0]);
    return jsts.algorithm.MinimumDiameter.inputGeom.getFactory().createPolygon(shell, null);
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

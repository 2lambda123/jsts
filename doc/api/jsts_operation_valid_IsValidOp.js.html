<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/operation/valid/IsValidOp.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/operation/valid/IsValidOp.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Implements the algorithms required to compute the &lt;code>isValid()&lt;/code>
 * method for {@link Geometry}s. See the documentation for the various geometry
 * types for a specification of validity.
 *
 * @version 1.7
 * @constructor
 */

jsts.operation.valid.IsValidOp = function(parentGeometry) {
  this.parentGeometry = parentGeometry;
  this.isSelfTouchingRingFormingHoleValid = false;
  this.validErr = null;
};

/**
 * Tests whether a {@link Geometry} is valid.
 *
 * @param geom
 *          the Geometry to test.
 * @return true if the geometry is valid.
 */
jsts.operation.valid.IsValidOp.isValid = function(arg) {
  if (arguments[0] instanceof jsts.geom.Coordinate) {
    if (isNaN(arg.x)) {
      return false;
    }
    if (!isFinite(arg.x) &amp;&amp; !isNaN(arg.x)) {
      return false;
    }
    if (isNaN(arg.y)) {
      return false;
    }
    if (!isFinite(arg.y) &amp;&amp; !isNaN(arg.y)) {
      return false;
    }
    return true;
  } else {
    var isValidOp = new jsts.operation.valid.IsValidOp(arg);
    return isValidOp.isValid();
  }
};

/**
 * Find a point from the list of testCoords that is NOT a node in the edge for
 * the list of searchCoords
 *
 * @return the point found, or &lt;code>null&lt;/code> if none found.
 */
jsts.operation.valid.IsValidOp.findPtNotNode = function(testCoords, searchRing,
    graph) {
  // find edge corresponding to searchRing.
  var searchEdge = graph.findEdge(searchRing);
  // find a point in the testCoords which is not a node of the searchRing
  var eiList = searchEdge.getEdgeIntersectionList();
  // somewhat inefficient - is there a better way? (Use a node map, for
  // instance?)
  for (var i = 0; i &lt; testCoords.length; i++) {
    var pt = testCoords[i];
    if (!eiList.isIntersection(pt)) {
      return pt;
    }
  }
  return null;
};

/**
 * Sets whether polygons using &lt;b>Self-Touching Rings&lt;/b> to form holes are
 * reported as valid. If this flag is set, the following Self-Touching
 * conditions are treated as being valid:
 * &lt;ul>
 * &lt;li>the shell ring self-touches to create a hole touching the shell
 * &lt;li>a hole ring self-touches to create two holes touching at a point
 * &lt;/ul>
 * &lt;p>
 * The default (following the OGC SFS standard) is that this condition is &lt;b>not&lt;/b>
 * valid (&lt;code>false&lt;/code>).
 * &lt;p>
 * This does not affect whether Self-Touching Rings disconnecting the polygon
 * interior are considered valid (these are considered to be &lt;b>invalid&lt;/b>
 * under the SFS, and many other spatial models as well). This includes
 * "bow-tie" shells, which self-touch at a single point causing the interior to
 * be disconnected, and "C-shaped" holes which self-touch at a single point
 * causing an island to be formed.
 *
 * @param isValid
 *          states whether geometry with this condition is valid.
 */
jsts.operation.valid.IsValidOp.prototype.setSelfTouchingRingFormingHoleValid = function(
    isValid) {
  this.isSelfTouchingRingFormingHoleValid = isValid;
};

jsts.operation.valid.IsValidOp.prototype.isValid = function() {
  this.checkValid(this.parentGeometry);
  return this.validErr == null;
};

jsts.operation.valid.IsValidOp.prototype.getValidationError = function() {
  this.checkValid(this.parentGeometry);
  return this.validErr;
};

jsts.operation.valid.IsValidOp.prototype.checkValid = function(g) {
  this.validErr = null;

  // empty geometries are always valid!
  if (g.isEmpty()) {
    return;
  }

  if (g instanceof jsts.geom.Point) {
    this.checkValidPoint(g);
  } else if (g instanceof jsts.geom.MultiPoint) {
    this.checkValidMultiPoint(g);
    // LineString also handles LinearRings
  } else if (g instanceof jsts.geom.LinearRing) {
    this.checkValidLinearRing(g);
  } else if (g instanceof jsts.geom.LineString) {
    this.checkValidLineString(g);
  } else if (g instanceof jsts.geom.Polygon) {
    this.checkValidPolygon(g);
  } else if (g instanceof jsts.geom.MultiPolygon) {
    this.checkValidMultiPolygon(g);
  } else if (g instanceof jsts.geom.GeometryCollection) {
    this.checkValidGeometryCollection(g);
  } else {
    throw g.constructor;
  }
};

/**
 * Checks validity of a Point.
 */
jsts.operation.valid.IsValidOp.prototype.checkValidPoint = function(g) {
  this.checkInvalidCoordinates(g.getCoordinates());
};
/**
 * Checks validity of a MultiPoint.
 */
jsts.operation.valid.IsValidOp.prototype.checkValidMultiPoint = function(g) {
  this.checkInvalidCoordinates(g.getCoordinates());
};

/**
 * Checks validity of a LineString. Almost anything goes for linestrings!
 */
jsts.operation.valid.IsValidOp.prototype.checkValidLineString = function(g) {
  this.checkInvalidCoordinates(g.getCoordinates());
  if (this.validErr != null) {
    return;
  }
  var graph = new jsts.geomgraph.GeometryGraph(0, g);
  this.checkTooFewPoints(graph);
};
/**
 * Checks validity of a LinearRing.
 */
jsts.operation.valid.IsValidOp.prototype.checkValidLinearRing = function(g) {
  this.checkInvalidCoordinates(g.getCoordinates());
  if (this.validErr != null) {
    return;
  }
  this.checkClosedRing(g);
  if (this.validErr != null) {
    return;
  }
  var graph = new jsts.geomgraph.GeometryGraph(0, g);
  this.checkTooFewPoints(graph);
  if (this.validErr != null) {
    return;
  }
  var li = new jsts.algorithm.RobustLineIntersector();
  graph.computeSelfNodes(li, true);
  this.checkNoSelfIntersectingRings(graph);
};

/**
 * Checks the validity of a polygon. Sets the validErr flag.
 */
jsts.operation.valid.IsValidOp.prototype.checkValidPolygon = function(g) {
  this.checkInvalidCoordinates(g);
  if (this.validErr != null) {
    return;
  }
  this.checkClosedRings(g);
  if (this.validErr != null) {
    return;
  }

  var graph = new jsts.geomgraph.GeometryGraph(0, g);

  this.checkTooFewPoints(graph);
  if (this.validErr != null) {
    return;
  }
  this.checkConsistentArea(graph);
  if (this.validErr != null) {
    return;
  }

  if (!this.isSelfTouchingRingFormingHoleValid) {
    this.checkNoSelfIntersectingRings(graph);
    if (this.validErr != null) {
      return;
    }
  }
  this.checkHolesInShell(g, graph);
  if (this.validErr != null) {
    return;
  }
  // SLOWcheckHolesNotNested(g);
  this.checkHolesNotNested(g, graph);
  if (this.validErr != null) {
    return;
  }
  this.checkConnectedInteriors(graph);
};

jsts.operation.valid.IsValidOp.prototype.checkValidMultiPolygon = function(g) {
  var il = g.getNumGeometries();
  for (var i = 0; i &lt; il; i++) {
    var p = g.getGeometryN(i);
    this.checkInvalidCoordinates(p);
    if (this.validErr != null) {
      return;
    }
    this.checkClosedRings(p);
    if (this.validErr != null) {
      return;
    }
  }
  // Add this
  var graph = new jsts.geomgraph.GeometryGraph(0, g);

  this.checkTooFewPoints(graph);
  if (this.validErr != null) {
    return;
  }
  this.checkConsistentArea(graph);
  if (this.validErr != null) {
    return;
  }
  if (!this.isSelfTouchingRingFormingHoleValid) {
    this.checkNoSelfIntersectingRings(graph);
    if (this.validErr != null) {
      return;
    }
  }
  for (var i = 0; i &lt; g.getNumGeometries(); i++) {
    var p = g.getGeometryN(i);
    this.checkHolesInShell(p, graph);
    if (this.validErr != null) {
      return;
    }
  }
  for (var i = 0; i &lt; g.getNumGeometries(); i++) {
    var p = g.getGeometryN(i);
    this.checkHolesNotNested(p, graph);
    if (this.validErr != null) {
      return;
    }
  }
  this.checkShellsNotNested(g, graph);
  if (this.validErr != null) {
    return;
  }
  this.checkConnectedInteriors(graph);
};

jsts.operation.valid.IsValidOp.prototype.checkValidGeometryCollection = function(
    gc) {
  for (var i = 0; i &lt; gc.getNumGeometries(); i++) {
    var g = gc.getGeometryN(i);
    this.checkValid(g);
    if (this.validErr != null) {
      return;
    }
  }
};

jsts.operation.valid.IsValidOp.prototype.checkInvalidCoordinates = function(
    arg) {
  if (arg instanceof jsts.geom.Polygon) {
    var poly = arg;
    this.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());
    if (this.validErr != null) {
      return;
    }
    for (var i = 0; i &lt; poly.getNumInteriorRing(); i++) {
      this.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());
      if (this.validErr != null) {
        return;
      }
    }
  } else {
    var coords = arg;
    for (var i = 0; i &lt; coords.length; i++) {
      if (!jsts.operation.valid.IsValidOp.isValid(coords[i])) {
        this.validErr = new jsts.operation.valid.TopologyValidationError(
            jsts.operation.valid.TopologyValidationError.INVALID_COORDINATE,
            coords[i]);
        return;
      }
    }
  }
};

jsts.operation.valid.IsValidOp.prototype.checkClosedRings = function(poly) {
  // checkClosedRing((LinearRing) poly.getExteriorRing());
  this.checkClosedRing(poly.getExteriorRing());
  if (this.validErr != null) {
    return;
  }
  for (var i = 0; i &lt; poly.getNumInteriorRing(); i++) {
    // checkClosedRing((LinearRing) poly.getInteriorRingN(i));
    this.checkClosedRing(poly.getInteriorRingN(i));
    if (this.validErr != null) {
      return;
    }
  }
};

jsts.operation.valid.IsValidOp.prototype.checkClosedRing = function(ring) {
  if (!ring.isClosed()) {
    var pt = null;
    if (ring.getNumPoints() >= 1) {
      pt = ring.getCoordinateN(0);
    }
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.RING_NOT_CLOSED, pt);
  }
};

jsts.operation.valid.IsValidOp.prototype.checkTooFewPoints = function(graph) {
  if (graph.hasTooFewPoints) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.TOO_FEW_POINTS, graph
            .getInvalidPoint());
    return;
  }
};

/**
 * Checks that the arrangement of edges in a polygonal geometry graph forms a
 * consistent area.
 *
 * @param graph
 *
 * @see ConsistentAreaTester
 */
jsts.operation.valid.IsValidOp.prototype.checkConsistentArea = function(graph) {
  var cat = new jsts.operation.valid.ConsistentAreaTester(graph);
  var isValidArea = cat.isNodeConsistentArea();
  if (!isValidArea) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.SELF_INTERSECTION, cat
            .getInvalidPoint());
    return;
  }
  if (cat.hasDuplicateRings()) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.DUPLICATE_RINGS, cat
            .getInvalidPoint());
  }
};

/**
 * Check that there is no ring which self-intersects (except of course at its
 * endpoints). This is required by OGC topology rules (but not by other models
 * such as ESRI SDE, which allow inverted shells and exverted holes).
 *
 * @param graph
 *          the topology graph of the geometry.
 */
jsts.operation.valid.IsValidOp.prototype.checkNoSelfIntersectingRings = function(
    graph) {
  for (var i = graph.getEdgeIterator(); i.hasNext();) {
    var e = i.next();
    this.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());
    if (this.validErr != null) {
      return;
    }
  }
};

/**
 * Check that a ring does not self-intersect, except at its endpoints. Algorithm
 * is to count the number of times each node along edge occurs. If any occur
 * more than once, that must be a self-intersection.
 */
jsts.operation.valid.IsValidOp.prototype.checkNoSelfIntersectingRing = function(
    eiList) {
  var nodeSet = [];
  var isFirst = true;
  for (var i = eiList.iterator(); i.hasNext();) {
    var ei = i.next();
    if (isFirst) {
      isFirst = false;
      continue;
    }
    if (nodeSet.indexOf(ei.coord) >= 0) {
      this.validErr = new jsts.operation.valid.TopologyValidationError(
          jsts.operation.valid.TopologyValidationError.RING_SELF_INTERSECTION,
          ei.coord);
      return;
    } else {
      nodeSet.push(ei.coord);
    }
  }
};

/**
 * Tests that each hole is inside the polygon shell. This routine assumes that
 * the holes have previously been tested to ensure that all vertices lie on the
 * shell oon the same side of it (i.e that the hole rings do not cross the shell
 * ring). In other words, this test is only correct if the ConsistentArea test
 * is passed first. Given this, a simple point-in-polygon test of a single point
 * in the hole can be used, provided the point is chosen such that it does not
 * lie on the shell.
 *
 * @param p
 *          the polygon to be tested for hole inclusion.
 * @param graph
 *          a GeometryGraph incorporating the polygon.
 */
jsts.operation.valid.IsValidOp.prototype.checkHolesInShell = function(p, graph) {
  var shell = p.getExteriorRing();

  // PointInRing pir = new SimplePointInRing(shell);
  // PointInRing pir = new SIRtreePointInRing(shell);

  var pir = new jsts.algorithm.MCPointInRing(shell);

  for (var i = 0; i &lt; p.getNumInteriorRing(); i++) {

    var hole = p.getInteriorRingN(i); // Cast?
    var holePt = jsts.operation.valid.IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);
    /**
     * If no non-node hole vertex can be found, the hole must split the polygon
     * into disconnected interiors. This will be caught by a subsequent check.
     */
    if (holePt == null) {
      return;
    }

    var outside = !pir.isInside(holePt);
    if (outside) {
      this.validErr = new jsts.operation.valid.TopologyValidationError(
          jsts.operation.valid.TopologyValidationError.HOLE_OUTSIDE_SHELL,
          holePt);
      return;
    }
  }
};

/**
 * Tests that no hole is nested inside another hole. This routine assumes that
 * the holes are disjoint. To ensure this, holes have previously been tested to
 * ensure that:
 * &lt;ul>
 * &lt;li>they do not partially overlap (checked by
 * &lt;code>checkRelateConsistency&lt;/code>)
 * &lt;li>they are not identical (checked by &lt;code>checkRelateConsistency&lt;/code>)
 * &lt;/ul>
 */
jsts.operation.valid.IsValidOp.prototype.checkHolesNotNested = function(p,
    graph) {
  var nestedTester = new jsts.operation.valid.IndexedNestedRingTester(graph);
  // SimpleNestedRingTester nestedTester = new SimpleNestedRingTester(arg[0]);
  // SweeplineNestedRingTester nestedTester = new
  // SweeplineNestedRingTester(arg[0]);

  for (var i = 0; i &lt; p.getNumInteriorRing(); i++) {
    var innerHole = p.getInteriorRingN(i);
    nestedTester.add(innerHole);
  }
  var isNonNested = nestedTester.isNonNested();
  if (!isNonNested) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.NESTED_HOLES, nestedTester
            .getNestedPoint());
  }
};

/**
 * Tests that no element polygon is wholly in the interior of another element
 * polygon.
 * &lt;p>
 * Preconditions:
 * &lt;ul>
 * &lt;li>shells do not partially overlap
 * &lt;li>shells do not touch along an edge
 * &lt;li>no duplicate rings exist
 * &lt;/ul>
 * This routine relies on the fact that while polygon shells may touch at one or
 * more vertices, they cannot touch at ALL vertices.
 */
jsts.operation.valid.IsValidOp.prototype.checkShellsNotNested = function(mp,
    graph) {
  for (var i = 0; i &lt; mp.getNumGeometries(); i++) {
    var p = mp.getGeometryN(i);
    var shell = p.getExteriorRing();
    for (var j = 0; j &lt; mp.getNumGeometries(); j++) {
      if (i == j) {
        continue;
      }
      var p2 = mp.getGeometryN(j);
      this.checkShellNotNested(shell, p2, graph);
      if (this.validErr != null) {
        return;
      }
    }
  }
};

/**
 * Check if a shell is incorrectly nested within a polygon. This is the case if
 * the shell is inside the polygon shell, but not inside a polygon hole. (If the
 * shell is inside a polygon hole, the nesting is valid.)
 * &lt;p>
 * The algorithm used relies on the fact that the rings must be properly
 * contained. E.g. they cannot partially overlap (this has been previously
 * checked by &lt;code>checkRelateConsistency&lt;/code> )
 */
jsts.operation.valid.IsValidOp.prototype.checkShellNotNested = function(shell,
    p, graph) {
  var shellPts = shell.getCoordinates();
  // test if shell is inside polygon shell
  var polyShell = p.getExteriorRing();
  var polyPts = polyShell.getCoordinates();
  var shellPt = jsts.operation.valid.IsValidOp.findPtNotNode(shellPts, polyShell, graph);
  // if no point could be found, we can assume that the shell is outside the
  // polygon
  if (shellPt == null) {
    return;
  }
  var insidePolyShell = jsts.algorithm.CGAlgorithms.isPointInRing(shellPt, polyPts);
  if (!insidePolyShell) {
    return;
  }

  // if no holes, this is an error!
  if (p.getNumInteriorRing() &lt;= 0) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.NESTED_SHELLS, shellPt);
    return;
  }

  /**
   * Check if the shell is inside one of the holes. This is the case if one of
   * the calls to checkShellInsideHole returns a null coordinate. Otherwise, the
   * shell is not properly contained in a hole, which is an error.
   */
  var badNestedPt = null;
  for (var i = 0; i &lt; p.getNumInteriorRing(); i++) {
    var hole = p.getInteriorRingN(i);
    badNestedPt = this.checkShellInsideHole(shell, hole, graph);
    if (badNestedPt == null) {
      return;
    }
  }
  this.validErr = new jsts.operation.valid.TopologyValidationError(
      jsts.operation.valid.TopologyValidationError.NESTED_SHELLS, badNestedPt);
};

/**
 * This routine checks to see if a shell is properly contained in a hole. It
 * assumes that the edges of the shell and hole do not properly intersect.
 *
 * @return &lt;code>null&lt;/code> if the shell is properly contained, or a
 *         Coordinate which is not inside the hole if it is not.
 *
 */
jsts.operation.valid.IsValidOp.prototype.checkShellInsideHole = function(shell,
    hole, graph) {
  var shellPts = shell.getCoordinates();
  var holePts = hole.getCoordinates();
  // TODO: improve performance of this - by sorting pointlists for instance?
  var shellPt = jsts.operation.valid.IsValidOp.findPtNotNode(shellPts, hole, graph);
  // if point is on shell but not hole, check that the shell is inside the
  // hole
  if (shellPt != null) {
    var insideHole = jsts.algorithm.CGAlgorithms.isPointInRing(shellPt, holePts);
    if (!insideHole) {
      return shellPt;
    }
  }
  var holePt = jsts.operation.valid.IsValidOp.findPtNotNode(holePts, shell, graph);
  // if point is on hole but not shell, check that the hole is outside the
  // shell
  if (holePt != null) {
    var insideShell = jsts.algorithm.CGAlgorithms.isPointInRing(holePt, shellPts);
    if (insideShell) {
      return holePt;
    }
    return null;
  }
  jsts.util.Assert
      .shouldNeverReachHere('points in shell and hole appear to be equal');
  return null;
};

jsts.operation.valid.IsValidOp.prototype.checkConnectedInteriors = function(
    graph) {
  var cit = new jsts.operation.valid.ConnectedInteriorTester(graph);
  if (!cit.isInteriorsConnected()) {
    this.validErr = new jsts.operation.valid.TopologyValidationError(
        jsts.operation.valid.TopologyValidationError.DISCONNECTED_INTERIOR, cit
            .getCoordinate());
  }

};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/geom/IntersectionMatrix.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/geom/IntersectionMatrix.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/geom/Dimension.js
   */

  var Location = jsts.geom.Location;
  var Dimension = jsts.geom.Dimension;

  /**
   * Models a Dimensionally Extended Nine-Intersection Model (DE-9IM) matrix.
   * This class is used to represent intersection matrices (such as "212FF1FF2")
   * capturing the topological relationship between two {@link Geometry}s. It
   * can also be represent patterns (such as "T*T******")for matching existing
   * matrices.
   *
   * Methods are provided to:
   * &lt;UL>
   * &lt;LI> set and query the elements of the matrix in a convenient fashion
   * &lt;LI> convert to and from the standard string representation (specified in
   * SFS Section 2.1.13.2).
   * &lt;LI> test to see if a matrix matches a given pattern string.
   * &lt;/UL>
   * &lt;P>
   *
   * For a description of the DE-9IM, see the &lt;A
   * HREF="http://www.opengis.org/techno/specs.htm">OpenGIS Simple Features
   * Specification for SQL&lt;/A>.
   *
   * The entries of the matrix are defined by the constants in the
   * {@link Dimension} class. The indices of the matrix represent the
   * topological locations that occur in a geometry (Interior, Boundary,
   * Exterior). These are provided as constants in the {@link Location} class.
   *
   * @param {string/IntersectionMatrix}
   *          elements
   * @constructor
   */
  jsts.geom.IntersectionMatrix = function(elements) {
    var other = elements;

    if (elements === undefined || elements === null) {
      this.matrix = [[], [], []];
      this.setAll(Dimension.FALSE);
    } else if (typeof elements === 'string') {
      this.set(elements);
    } else if (other instanceof jsts.geom.IntersectionMatrix) {

      this.matrix[Location.INTERIOR][Location.INTERIOR] = other.matrix[Location.INTERIOR][Location.INTERIOR];
      this.matrix[Location.INTERIOR][Location.BOUNDARY] = other.matrix[Location.INTERIOR][Location.BOUNDARY];
      this.matrix[Location.INTERIOR][Location.EXTERIOR] = other.matrix[Location.INTERIOR][Location.EXTERIOR];
      this.matrix[Location.BOUNDARY][Location.INTERIOR] = other.matrix[Location.BOUNDARY][Location.INTERIOR];
      this.matrix[Location.BOUNDARY][Location.BOUNDARY] = other.matrix[Location.BOUNDARY][Location.BOUNDARY];
      this.matrix[Location.BOUNDARY][Location.EXTERIOR] = other.matrix[Location.BOUNDARY][Location.EXTERIOR];
      this.matrix[Location.EXTERIOR][Location.INTERIOR] = other.matrix[Location.EXTERIOR][Location.INTERIOR];
      this.matrix[Location.EXTERIOR][Location.BOUNDARY] = other.matrix[Location.EXTERIOR][Location.BOUNDARY];
      this.matrix[Location.EXTERIOR][Location.EXTERIOR] = other.matrix[Location.EXTERIOR][Location.EXTERIOR];
    }
  };


  /**
   * Internal representation of this &lt;code>IntersectionMatrix&lt;/code>.
   *
   * @type {int[][]}
   * @private
   */
  jsts.geom.IntersectionMatrix.prototype.matrix = null;


  /**
   * Adds one matrix to another. Addition is defined by taking the maximum
   * dimension value of each position in the summand matrices.
   *
   * @param {IntersectionMatrix}
   *          im the matrix to add.
   */
  jsts.geom.IntersectionMatrix.prototype.add = function(im) {
    var i, j;
    for (i = 0; i &lt; 3; i++) {
      for (j = 0; j &lt; 3; j++) {
        this.setAtLeast(i, j, im.get(i, j));
      }
    }
  };


  /**
   * Returns true if the dimension value satisfies the dimension symbol.
   *
   * @param {int}
   *          actualDimensionValue a number that can be stored in the
   *          &lt;code>IntersectionMatrix&lt;/code> . Possible values are
   *          &lt;code>{TRUE, FALSE, DONTCARE, 0, 1, 2}&lt;/code>.
   * @param {string}
   *          requiredDimensionSymbol a character used in the string
   *          representation of an &lt;code>IntersectionMatrix&lt;/code>. Possible
   *          values are &lt;code>{T, F, * , 0, 1, 2}&lt;/code>.
   * @return {boolean} true if the dimension symbol encompasses the dimension
   *         value.
   */
  jsts.geom.IntersectionMatrix.matches = function(actualDimensionValue,
      requiredDimensionSymbol) {
    if (typeof actualDimensionValue === 'string') {
      return jsts.geom.IntersectionMatrix.matches2.call(this, arguments);
    }

    if (requiredDimensionSymbol === '*') {
      return true;
    }
    if (requiredDimensionSymbol === 'T' &amp;&amp;
        (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {
      return true;
    }
    if (requiredDimensionSymbol === 'F' &amp;&amp;
        actualDimensionValue === Dimension.FALSE) {
      return true;
    }
    if (requiredDimensionSymbol === '0' &amp;&amp; actualDimensionValue === Dimension.P) {
      return true;
    }
    if (requiredDimensionSymbol === '1' &amp;&amp; actualDimensionValue === Dimension.L) {
      return true;
    }
    if (requiredDimensionSymbol === '2' &amp;&amp; actualDimensionValue === Dimension.A) {
      return true;
    }
    return false;
  };


  /**
   * Returns true if each of the actual dimension symbols satisfies the
   * corresponding required dimension symbol.
   *
   * @param {string}
   *          actualDimensionSymbols nine dimension symbols to validate.
   *          Possible values are &lt;code>{T, F, * , 0, 1, 2}&lt;/code>.
   * @param {string}
   *          requiredDimensionSymbols nine dimension symbols to validate
   *          against. Possible values are &lt;code>{T, F, * , 0, 1, 2}&lt;/code>.
   * @return {boolean} true if each of the required dimension symbols encompass
   *         the corresponding actual dimension symbol.
   */
  jsts.geom.IntersectionMatrix.matches2 = function(actualDimensionSymbols,
      requiredDimensionSymbols) {
    var m = new jsts.geom.IntersectionMatrix(actualDimensionSymbols);
    return m.matches(requiredDimensionSymbols);
  };


  /**
   * Changes the value of one of this &lt;code>IntersectionMatrix&lt;/code>s
   * elements.
   *
   * @param {int}
   *          row the row of this &lt;code>IntersectionMatrix&lt;/code>, indicating
   *          the interior, boundary or exterior of the first
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          column the column of this &lt;code>IntersectionMatrix&lt;/code>,
   *          indicating the interior, boundary or exterior of the second
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          dimensionValue the new value of the element.
   */
  jsts.geom.IntersectionMatrix.prototype.set = function(row, column, dimensionValue) {
	if (typeof row === 'string') {
		this.set2(row);
		return;
	}
	this.matrix[row][column] = dimensionValue;    
  };


  /**
   * Changes the elements of this &lt;code>IntersectionMatrix&lt;/code> to the
   * dimension symbols in &lt;code>dimensionSymbols&lt;/code>.
   *
   * @param {String}
   *          dimensionSymbols nine dimension symbols to which to set this
   *          &lt;code>IntersectionMatrix&lt;/code> s elements. Possible values are
   *          &lt;code>{T, F, * , 0, 1, 2}.&lt;/code>
   */
  jsts.geom.IntersectionMatrix.prototype.set2 = function(dimensionSymbols) {
	this.matrix = [[], [], []]; this.setAll(Dimension.FALSE);
	for (var i = 0; i &lt; dimensionSymbols.length; i++) {
		var col = i % 3;
		var row = Math.floor(i / 3);
		this.matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));
	}    
  };

  /**
   * Changes the specified element to &lt;code>minimumDimensionValue&lt;/code> if
   * the element is less.
   *
   * @param {int}
   *          row the row of this &lt;code>IntersectionMatrix&lt;/code> , indicating
   *          the interior, boundary or exterior of the first
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          column the column of this &lt;code>IntersectionMatrix&lt;/code> ,
   *          indicating the interior, boundary or exterior of the second
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          minimumDimensionValue the dimension value with which to compare
   *          the element. The order of dimension values from least to greatest
   *          is &lt;code>{DONTCARE, TRUE, FALSE, 0, 1, 2}&lt;/code>.
   */
  jsts.geom.IntersectionMatrix.prototype.setAtLeast = function(row, column,
      minimumDimensionValue) {
    if (arguments.length === 1) {
      this.setAtLeast2(arguments[0]);
      return;
    }

    if (this.matrix[row][column] &lt; minimumDimensionValue) {
      this.matrix[row][column] = minimumDimensionValue;
    }
  };


  /**
   * If row >= 0 and column >= 0, changes the specified element to
   * &lt;code>minimumDimensionValue&lt;/code> if the element is less. Does nothing
   * if row &lt;0 or column &lt; 0.
   *
   * @param {int}
   *          row the row of this &lt;code>IntersectionMatrix&lt;/code> , indicating
   *          the interior, boundary or exterior of the first
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          column the column of this &lt;code>IntersectionMatrix&lt;/code> ,
   *          indicating the interior, boundary or exterior of the second
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          minimumDimensionValue the dimension value with which to compare
   *          the element. The order of dimension values from least to greatest
   *          is &lt;code>{DONTCARE, TRUE, FALSE, 0, 1, 2}&lt;/code>.
   */
  jsts.geom.IntersectionMatrix.prototype.setAtLeastIfValid = function(row, column,
      minimumDimensionValue) {
    if (row >= 0 &amp;&amp; column >= 0) {
      this.setAtLeast(row, column, minimumDimensionValue);
    }
  };


  /**
   * For each element in this &lt;code>IntersectionMatrix&lt;/code>, changes the
   * element to the corresponding minimum dimension symbol if the element is
   * less.
   *
   * @param {string}
   *          minimumDimensionSymbols nine dimension symbols with which to
   *          compare the elements of this &lt;code>IntersectionMatrix&lt;/code>.
   *          The order of dimension values from least to greatest is
   *          &lt;code>{DONTCARE, TRUE, FALSE, 0, 1, 2}&lt;/code> .
   */
  jsts.geom.IntersectionMatrix.prototype.setAtLeast2 = function(minimumDimensionSymbols) {
    var i;
    for (i = 0; i &lt; minimumDimensionSymbols.length; i++) {
      var row = parseInt(i / 3);
      var col = parseInt(i % 3);
      this.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));
    }
  };


  /**
   * Changes the elements of this &lt;code>IntersectionMatrix&lt;/code> to
   * &lt;code>dimensionValue&lt;/code> .
   *
   * @param {int}
   *          dimensionValue the dimension value to which to set this
   *          &lt;code>IntersectionMatrix&lt;/code> s elements. Possible values
   *          &lt;code>{TRUE, FALSE, DONTCARE, 0, 1, 2}&lt;/code> .
   */
  jsts.geom.IntersectionMatrix.prototype.setAll = function(dimensionValue) {
    var ai, bi;
    for (ai = 0; ai &lt; 3; ai++) {
      for (bi = 0; bi &lt; 3; bi++) {
        this.matrix[ai][bi] = dimensionValue;
      }
    }
  };


  /**
   * Returns the value of one of this matrix entries. The value of the provided
   * index is one of the values from the {@link Location} class. The value
   * returned is a constant from the {@link Dimension} class.
   *
   * @param {int}
   *          row the row of this &lt;code>IntersectionMatrix&lt;/code>, indicating
   *          the interior, boundary or exterior of the first
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          column the column of this &lt;code>IntersectionMatrix&lt;/code>,
   *          indicating the interior, boundary or exterior of the second
   *          &lt;code>Geometry.&lt;/code>
   * @return {int} the dimension value at the given matrix position.
   */
  jsts.geom.IntersectionMatrix.prototype.get = function(row, column) {
    return this.matrix[row][column];
  };


  /**
   * Returns &lt;code>true&lt;/code> if this &lt;code>IntersectionMatrix&lt;/code> is
   * FF*FF****.
   *
   * @return {boolean} &lt;code>true&lt;/code> if the two &lt;code>Geometry&lt;/code>s
   *         related by this &lt;code>IntersectionMatrix&lt;/code> are disjoint.
   */
  jsts.geom.IntersectionMatrix.prototype.isDisjoint = function() {
    return this.matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE &amp;&amp;
        this.matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE &amp;&amp;
        this.matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE &amp;&amp;
        this.matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;
  };


  /**
   * Returns &lt;code>true&lt;/code> if &lt;code>isDisjoint&lt;/code> returns false.
   *
   * @return {boolean} &lt;code>true&lt;/code> if the two &lt;code>Geometry&lt;/code>s
   *         related by this &lt;code>IntersectionMatrix&lt;/code> intersect.
   */
  jsts.geom.IntersectionMatrix.prototype.isIntersects = function() {
    return !this.isDisjoint();
  };


  /**
   * Returns &lt;code>true&lt;/code> if this &lt;code>IntersectionMatrix&lt;/code> is
   * FT*******, F**T***** or F***T****.
   *
   * @param {int}
   *          dimensionOfGeometryA the dimension of the first
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          dimensionOfGeometryB the dimension of the second
   *          &lt;code>Geometry.&lt;/code>
   * @return {boolean} &lt;code>true&lt;/code> if the two &lt;code>Geometry&lt;/code> s
   *         related by this &lt;code>IntersectionMatrix&lt;/code> touch; Returns
   *         false if both &lt;code>Geometry&lt;/code>s are points.
   */
  jsts.geom.IntersectionMatrix.prototype.isTouches = function(dimensionOfGeometryA,
      dimensionOfGeometryB) {
    if (dimensionOfGeometryA > dimensionOfGeometryB) {
      // no need to get transpose because pattern matrix is symmetrical
      return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);
    }
    if ((dimensionOfGeometryA == Dimension.A &amp;&amp; dimensionOfGeometryB == Dimension.A) ||
        (dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.L) ||
        (dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.A) ||
        (dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.A) ||
        (dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.L)) {
      return this.matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE &amp;&amp;
          (jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.INTERIOR][Location.BOUNDARY], 'T') ||
              jsts.geom.IntersectionMatrix.matches(
                  this.matrix[Location.BOUNDARY][Location.INTERIOR], 'T') || jsts.geom.IntersectionMatrix
              .matches(this.matrix[Location.BOUNDARY][Location.BOUNDARY], 'T'));
    }
    return false;
  };


  /**
   * Tests whether this geometry crosses the specified geometry.
   * &lt;p>
   * The &lt;code>crosses&lt;/code> predicate has the following equivalent
   * definitions:
   * &lt;ul>
   * &lt;li>The geometries have some but not all interior points in common.
   * &lt;li>The DE-9IM Intersection Matrix for the two geometries is
   * &lt;ul>
   * &lt;li>T*T****** (for P/L, P/A, and L/A situations)
   * &lt;li>T*****T** (for L/P, L/A, and A/L situations)
   * &lt;li>0******** (for L/L situations)
   * &lt;/ul>
   * &lt;/ul>
   * For any other combination of dimensions this predicate returns
   * &lt;code>false&lt;/code>.
   * &lt;p>
   * The SFS defined this predicate only for P/L, P/A, L/L, and L/A situations.
   * JTS extends the definition to apply to L/P, A/P and A/L situations as well.
   * This makes the relation symmetric.
   *
   * @param {int}
   *          dimensionOfGeometryA the dimension of the first
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          dimensionOfGeometryB the dimension of the second
   *          &lt;code>Geometry.&lt;/code>
   * @return {boolean} &lt;code>true&lt;/code> if the two &lt;code>Geometry&lt;/code>s
   *         related by this &lt;code>IntersectionMatrix&lt;/code> cross.
   */
  jsts.geom.IntersectionMatrix.prototype.isCrosses = function(dimensionOfGeometryA,
      dimensionOfGeometryB) {
    if ((dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.L) ||
        (dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB == Dimension.A) ||
        (dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.A)) {
      return jsts.geom.IntersectionMatrix.matches(
          this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.INTERIOR][Location.EXTERIOR], 'T');
    }
    if ((dimensionOfGeometryA == Dimension.L &amp;&amp; dimensionOfGeometryB == Dimension.P) ||
        (dimensionOfGeometryA == Dimension.A &amp;&amp; dimensionOfGeometryB == Dimension.P) ||
        (dimensionOfGeometryA == Dimension.A &amp;&amp; dimensionOfGeometryB == Dimension.L)) {
      return jsts.geom.IntersectionMatrix.matches(
          matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.EXTERIOR][Location.INTERIOR], 'T');
    }
    if (dimensionOfGeometryA === Dimension.L &amp;&amp;
        dimensionOfGeometryB === Dimension.L) {
      return this.matrix[Location.INTERIOR][Location.INTERIOR] === 0;
    }
    return false;
  };


  /**
   * Tests whether this &lt;code>IntersectionMatrix&lt;/code> is T*F**F***.
   *
   * @return {boolean} &lt;code>true&lt;/code> if the first &lt;code>Geometry&lt;/code>
   *         is within the second.
   */
  jsts.geom.IntersectionMatrix.prototype.isWithin = function() {
    return jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
        this.matrix[Location.INTERIOR][Location.EXTERIOR] == Dimension.FALSE &amp;&amp;
        this.matrix[Location.BOUNDARY][Location.EXTERIOR] == Dimension.FALSE;
  };


  /**
   * Tests whether this &lt;code>IntersectionMatrix&lt;/code> is T*****FF*.
   *
   * @return {boolean} &lt;code>true&lt;/code> if the first &lt;code>Geometry&lt;/code>
   *         contains the second.
   */
  jsts.geom.IntersectionMatrix.prototype.isContains = function() {
    return jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
        this.matrix[Location.EXTERIOR][Location.INTERIOR] == Dimension.FALSE &amp;&amp;
        this.matrix[Location.EXTERIOR][Location.BOUNDARY] == Dimension.FALSE;
  };


  /**
   * Returns &lt;code>true&lt;/code> if this &lt;code>IntersectionMatrix&lt;/code> is
   * &lt;code>T*****FF*&lt;/code> or &lt;code>*T****FF*&lt;/code> or
   * &lt;code>***T**FF*&lt;/code> or &lt;code>****T*FF*&lt;/code>
   *
   * @return {boolean} &lt;code>true&lt;/code> if the first &lt;code>Geometry&lt;/code>
   *         covers the second.
   */
  jsts.geom.IntersectionMatrix.prototype.isCovers = function() {
    var hasPointInCommon = jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.INTERIOR][Location.BOUNDARY], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.BOUNDARY][Location.INTERIOR], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.BOUNDARY][Location.BOUNDARY], 'T');

    return hasPointInCommon &amp;&amp;
        this.matrix[Location.EXTERIOR][Location.INTERIOR] == Dimension.FALSE &amp;&amp;
        this.matrix[Location.EXTERIOR][Location.BOUNDARY] == Dimension.FALSE;
  };


  /**
   * Returns &lt;code>true&lt;/code> if this &lt;code>IntersectionMatrix&lt;/code> is
   * &lt;code>T*F**F***&lt;/code> or &lt;code>*TF**F***&lt;/code> or
   * &lt;code>**FT*F***&lt;/code> or &lt;code>**F*TF***&lt;/code>
   *
   * @return {boolean} &lt;code>true&lt;/code> if the first &lt;code>Geometry&lt;/code>
   *         is covered by the second.
   */
  jsts.geom.IntersectionMatrix.prototype.isCoveredBy = function() {
    var hasPointInCommon = jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.INTERIOR][Location.BOUNDARY], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.BOUNDARY][Location.INTERIOR], 'T') ||
        jsts.geom.IntersectionMatrix.matches(
            this.matrix[Location.BOUNDARY][Location.BOUNDARY], 'T');

    return hasPointInCommon &amp;&amp;
        this.matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE &amp;&amp;
        this.matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;
  };


  /**
   * Returns &lt;code>true&lt;/code> if this &lt;code>IntersectionMatrix&lt;/code> is
   * T*F**FFF*.
   *
   * @param {int}
   *          dimensionOfGeometryA the dimension of the first
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          dimensionOfGeometryB the dimension of the second
   *          &lt;code>Geometry.&lt;/code>
   * @return {boolean} &lt;code>true&lt;/code> if the two &lt;code>Geometry&lt;/code> s
   *         related by this &lt;code>IntersectionMatrix&lt;/code> are equal; the
   *         &lt;code>Geometry&lt;/code>s must have the same dimension for this
   *         function to return &lt;code>true.&lt;/code>
   */
  jsts.geom.IntersectionMatrix.prototype.isEquals = function(dimensionOfGeometryA,
      dimensionOfGeometryB) {
    if (dimensionOfGeometryA !== dimensionOfGeometryB) {
      return false;
    }
    return jsts.geom.IntersectionMatrix.matches(
        this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
        this.matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE &amp;&amp;
        this.matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE &amp;&amp;
        this.matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE &amp;&amp;
        this.matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;
  };


  /**
   * Returns &lt;code>true&lt;/code> if this &lt;code>IntersectionMatrix&lt;/code> is
   * &lt;UL>
   * &lt;LI> T*T***T** (for two points or two surfaces)
   * &lt;LI> 1*T***T** (for two curves)
   * &lt;/UL>.
   *
   * @param {int}
   *          dimensionOfGeometryA the dimension of the first
   *          &lt;code>Geometry.&lt;/code>
   * @param {int}
   *          dimensionOfGeometryB the dimension of the second
   *          &lt;code>Geometry.&lt;/code>
   * @return {boolean} &lt;code>true&lt;/code> if the two &lt;code>Geometry&lt;/code>s
   *         related by this &lt;code>IntersectionMatrix&lt;/code> overlap. For this
   *         function to return &lt;code>true&lt;/code>, the &lt;code>Geometry&lt;/code>s
   *         must be two points, two curves or two surfaces.
   */
  jsts.geom.IntersectionMatrix.prototype.isOverlaps = function(dimensionOfGeometryA,
      dimensionOfGeometryB) {
    if ((dimensionOfGeometryA == Dimension.P &amp;&amp; dimensionOfGeometryB === Dimension.P) ||
        (dimensionOfGeometryA == Dimension.A &amp;&amp; dimensionOfGeometryB === Dimension.A)) {
      return jsts.geom.IntersectionMatrix.matches(
          this.matrix[Location.INTERIOR][Location.INTERIOR], 'T') &amp;&amp;
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.INTERIOR][Location.EXTERIOR], 'T') &amp;&amp;
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.EXTERIOR][Location.INTERIOR], 'T');
    }
    if (dimensionOfGeometryA === Dimension.L &amp;&amp;
        dimensionOfGeometryB === Dimension.L) {
      return this.matrix[Location.INTERIOR][Location.INTERIOR] == 1 &amp;&amp;
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.INTERIOR][Location.EXTERIOR], 'T') &amp;&amp;
          jsts.geom.IntersectionMatrix.matches(
              this.matrix[Location.EXTERIOR][Location.INTERIOR], 'T');
    }
    return false;
  };


  /**
   * Returns whether the elements of this &lt;code>IntersectionMatrix&lt;/code>
   * satisfies the required dimension symbols.
   *
   * @param {string}
   *          requiredDimensionSymbols nine dimension symbols with which to
   *          compare the elements of this &lt;code>IntersectionMatrix&lt;/code>.
   *          Possible values are &lt;code>{T, F, * , 0, 1, 2}&lt;/code>.
   * @return {boolean} &lt;code>true&lt;/code> if this
   *         &lt;code>IntersectionMatrix&lt;/code> matches the required dimension
   *         symbols.
   */
  jsts.geom.IntersectionMatrix.prototype.matches = function(requiredDimensionSymbols) {
    if (requiredDimensionSymbols.length != 9) {
      throw new jsts.error.IllegalArgumentException('Should be length 9: ' +
          requiredDimensionSymbols);
    }
    for (var ai = 0; ai &lt; 3; ai++) {
      for (var bi = 0; bi &lt; 3; bi++) {
        if (!jsts.geom.IntersectionMatrix.matches(this.matrix[ai][bi],
            requiredDimensionSymbols.charAt(3 * ai + bi))) {
          return false;
        }
      }
    }
    return true;
  };


  /**
   * Transposes this jsts.geom.IntersectionMatrix.
   *
   * @return {IntersectionMatrix} this &lt;code>IntersectionMatrix&lt;/code> as a
   *         convenience.
   */
  jsts.geom.IntersectionMatrix.prototype.transpose = function() {
    var temp = matrix[1][0];
    this.matrix[1][0] = this.matrix[0][1];
    this.matrix[0][1] = temp;
    temp = this.matrix[2][0];
    this.matrix[2][0] = this.matrix[0][2];
    this.matrix[0][2] = temp;
    temp = this.matrix[2][1];
    this.matrix[2][1] = this.matrix[1][2];
    this.matrix[1][2] = temp;
    return this;
  };

  /**
   * Returns a nine-character &lt;code>String&lt;/code> representation of this
   * &lt;code>IntersectionMatrix&lt;/code> .
   *
   * @return {string} the nine dimension symbols of this
   *         &lt;code>IntersectionMatrix&lt;/code> in row-major order.
   */
  jsts.geom.IntersectionMatrix.prototype.toString = function() {
    var ai, bi, buf = '';
    for (ai = 0; ai &lt; 3; ai++) {
      for (bi = 0; bi &lt; 3; bi++) {
        buf += Dimension.toDimensionSymbol(this.matrix[ai][bi]);
      }
    }
    return buf;
  };

})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

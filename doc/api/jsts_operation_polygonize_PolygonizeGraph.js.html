<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/operation/polygonize/PolygonizeGraph.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/operation/polygonize/PolygonizeGraph.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Port source:
 * /jts/jts/java/src/com/vividsolutions/jts/operation/polygonize/PolygonizeDirectedEdge.java
 * Revision: 6
 */

/**
 * @requires jsts/operation/polygonize/EdgeRing.js
 * @requires jsts/operation/polygonize/PolygonizeEdge.js
 * @requires jsts/operation/polygonize/PolygonizeDirectedEdge.js
 * @requires jsts/geom/Coordinate.js
 * @requires jsts/planargraph/PlanarGraph.js
 * @requires jsts/planargraph/Node.js
 */

(function() {

  var ArrayList = javascript.util.ArrayList;
  var Stack = javascript.util.Stack;
  var HashSet = javascript.util.HashSet;
  var Assert = jsts.util.Assert;
  var EdgeRing = jsts.operation.polygonize.EdgeRing;
  var PolygonizeEdge = jsts.operation.polygonize.PolygonizeEdge;
  var PolygonizeDirectedEdge = jsts.operation.polygonize.PolygonizeDirectedEdge;
  var PlanarGraph = jsts.planargraph.PlanarGraph;
  var Node = jsts.planargraph.Node;

  /**
   * Represents a planar graph of edges that can be used to compute a
   * polygonization, and implements the algorithms to compute the
   * {@link EdgeRings} formed by the graph.
   * &lt;p>
   * The marked flag on {@link DirectedEdge}s is used to indicate that a
   * directed edge has be logically deleted from the graph.
   *
   * Create a new polygonization graph.
   */
  var PolygonizeGraph = function(factory) {
    PlanarGraph.apply(this);

    this.factory = factory;
  };

  PolygonizeGraph.prototype = new PlanarGraph();

  /**
   * @private
   */
  PolygonizeGraph.getDegreeNonDeleted = function(node) {
    var edges = node.getOutEdges().getEdges();
    var degree = 0;
    for (var i = edges.iterator(); i.hasNext();) {
      var de = i.next();
      if (!de.isMarked())
        degree++;
    }
    return degree;
  };

  /**
   * @private
   */
  PolygonizeGraph.getDegree = function(node, label) {
    var edges = node.getOutEdges().getEdges();
    var degree = 0;
    for (var i = edges.iterator(); i.hasNext();) {
      var de = i.next();
      if (de.getLabel() == label)
        degree++;
    }
    return degree;
  };

  /**
   * Deletes all edges at a node
   *
   * @private
   */
  PolygonizeGraph.deleteAllEdges = function(node) {
    var edges = node.getOutEdges().getEdges();
    for (var i = edges.iterator(); i.hasNext();) {
      var de = i.next();
      de.setMarked(true);
      var sym = de.getSym();
      if (sym != null)
        sym.setMarked(true);
    }
  };


  PolygonizeGraph.prototype.factory = null;


  /**
   * Add a {@link LineString} forming an edge of the polygon graph.
   *
   * @param line
   *          the line to add.
   */
  PolygonizeGraph.prototype.addEdge = function(line) {
    if (line.isEmpty()) {
      return;
    }
    var linePts = jsts.geom.CoordinateArrays.removeRepeatedPoints(line.getCoordinates());

    if (linePts.length &lt; 2) {
      return;
    }

    var startPt = linePts[0];
    var endPt = linePts[linePts.length - 1];

    var nStart = this.getNode(startPt);
    var nEnd = this.getNode(endPt);

    var de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);
    var de1 = new PolygonizeDirectedEdge(nEnd, nStart,
        linePts[linePts.length - 2], false);
    var edge = new PolygonizeEdge(line);
    edge.setDirectedEdges(de0, de1);
    this.add(edge);
  };

  /**
   * @private
   */
  PolygonizeGraph.prototype.getNode = function(pt) {
    var node = this.findNode(pt);
    if (node == null) {
      node = new Node(pt);
      // ensure node is only added once to graph
      this.add(node);
    }
    return node;
  };

  /**
   * @private
   */
  PolygonizeGraph.prototype.computeNextCWEdges = function() {
    // set the next pointers for the edges around each node
    for (var iNode = this.nodeIterator(); iNode.hasNext();) {
      var node = iNode.next();
      PolygonizeGraph.computeNextCWEdges(node);
    }
  };

  /**
   * Convert the maximal edge rings found by the initial graph traversal into
   * the minimal edge rings required by JTS polygon topology rules.
   *
   * @param ringEdges
   *          the list of start edges for the edgeRings to convert.
   * @private
   */
  PolygonizeGraph.prototype.convertMaximalToMinimalEdgeRings = function(
      ringEdges) {
    for (var i = ringEdges.iterator(); i.hasNext();) {
      var de = i.next();
      var label = de.getLabel();
      var intNodes = PolygonizeGraph.findIntersectionNodes(de, label);

      if (intNodes == null)
        continue;
      // flip the next pointers on the intersection nodes to create minimal edge
      // rings
      for (var iNode = intNodes.iterator(); iNode.hasNext();) {
        var node = iNode.next();
        PolygonizeGraph.computeNextCCWEdges(node, label);
      }
    }
  };

  /**
   * Finds all nodes in a maximal edgering which are self-intersection nodes
   *
   * @param startDE
   * @param label
   * @return the list of intersection nodes found, or &lt;code>null&lt;/code> if no
   *         intersection nodes were found.
   * @private
   */
  PolygonizeGraph.findIntersectionNodes = function(startDE, label) {
    var de = startDE;
    var intNodes = null;
    do {
      var node = de.getFromNode();
      if (PolygonizeGraph.getDegree(node, label) > 1) {
        if (intNodes == null)
          intNodes = new ArrayList();
        intNodes.add(node);
      }

      de = de.getNext();
      Assert.isTrue(de != null, 'found null DE in ring');
      Assert
          .isTrue(de == startDE || !de.isInRing(), 'found DE already in ring');
    } while (de != startDE);

    return intNodes;
  };

  /**
   * Computes the minimal EdgeRings formed by the edges in this graph.
   *
   * @return a list of the {@link EdgeRing} s found by the polygonization
   *         process.
   *
   */
  PolygonizeGraph.prototype.getEdgeRings = function() {
    // maybe could optimize this, since most of these pointers should be set
    // correctly already
    // by deleteCutEdges()
    this.computeNextCWEdges();
    // clear labels of all edges in graph
    PolygonizeGraph.label(this.dirEdges, -1);
    var maximalRings = PolygonizeGraph.findLabeledEdgeRings(this.dirEdges);
    this.convertMaximalToMinimalEdgeRings(maximalRings);

    // find all edgerings (which will now be minimal ones, as required)
    var edgeRingList = new ArrayList();
    for (var i = this.dirEdges.iterator(); i.hasNext();) {
      var de = i.next();
      if (de.isMarked())
        continue;
      if (de.isInRing())
        continue;

      var er = this.findEdgeRing(de);
      edgeRingList.add(er);
    }
    return edgeRingList;
  };

  /**
   * Finds and labels all edgerings in the graph. The edge rings are labelling
   * with unique integers. The labelling allows detecting cut edges.
   *
   * @param dirEdges
   *          a List of the DirectedEdges in the graph.
   * @return a List of DirectedEdges, one for each edge ring found.
   * @private
   */
  PolygonizeGraph.findLabeledEdgeRings = function(dirEdges) {
    var edgeRingStarts = new ArrayList();
    // label the edge rings formed
    var currLabel = 1;
    for (var i = dirEdges.iterator(); i.hasNext();) {
      var de = i.next();
      if (de.isMarked())
        continue;
      if (de.getLabel() >= 0)
        continue;

      edgeRingStarts.add(de);
      var edges = PolygonizeGraph.findDirEdgesInRing(de);

      PolygonizeGraph.label(edges, currLabel);
      currLabel++;
    }
    return edgeRingStarts;
  };

  /**
   * Finds and removes all cut edges from the graph.
   *
   * @return a list of the {@link LineString} s forming the removed cut edges.
   */
  PolygonizeGraph.prototype.deleteCutEdges = function() {
    this.computeNextCWEdges();
    // label the current set of edgerings
    PolygonizeGraph.findLabeledEdgeRings(this.dirEdges);

    /**
     * Cut Edges are edges where both dirEdges have the same label. Delete them,
     * and record them
     */
    var cutLines = new ArrayList();
    for (var i = this.dirEdges.iterator(); i.hasNext();) {
      var de = i.next();
      if (de.isMarked())
        continue;

      var sym = de.getSym();

      if (de.getLabel() == sym.getLabel()) {
        de.setMarked(true);
        sym.setMarked(true);

        // save the line as a cut edge
        var e = de.getEdge();
        cutLines.add(e.getLine());
      }
    }
    return cutLines;
  };

  /**
   * @private
   */
  PolygonizeGraph.label = function(dirEdges, label) {
    for (var i = dirEdges.iterator(); i.hasNext();) {
      var de = i.next();
      de.setLabel(label);
    }
  };

  /**
   * @private
   */
  PolygonizeGraph.computeNextCWEdges = function(node) {
    var deStar = node.getOutEdges();
    var startDE = null;
    var prevDE = null;

    // the edges are stored in CCW order around the star
    for (var i = deStar.getEdges().iterator(); i.hasNext();) {
      var outDE = i.next();
      if (outDE.isMarked())
        continue;

      if (startDE == null)
        startDE = outDE;
      if (prevDE != null) {
        var sym = prevDE.getSym();
        sym.setNext(outDE);
      }
      prevDE = outDE;
    }
    if (prevDE != null) {
      var sym = prevDE.getSym();
      sym.setNext(startDE);
    }
  };

  /**
   * Computes the next edge pointers going CCW around the given node, for the
   * given edgering label. This algorithm has the effect of converting maximal
   * edgerings into minimal edgerings
   *
   * @private
   *
   */
  PolygonizeGraph.computeNextCCWEdges = function(node, label) {
    var deStar = node.getOutEdges();
    // PolyDirectedEdge lastInDE = null;
    var firstOutDE = null;
    var prevInDE = null;

    // the edges are stored in CCW order around the star
    var edges = deStar.getEdges();
    // for (Iterator i = deStar.getEdges().iterator(); i.hasNext(); ) {
    for (var i = edges.size() - 1; i >= 0; i--) {
      var de = edges.get(i);
      var sym = de.getSym();

      var outDE = null;
      if (de.getLabel() == label)
        outDE = de;
      var inDE = null;
      if (sym.getLabel() == label)
        inDE = sym;

      if (outDE == null &amp;&amp; inDE == null)
        continue; // this edge is not in edgering

      if (inDE != null) {
        prevInDE = inDE;
      }

      if (outDE != null) {
        if (prevInDE != null) {
          prevInDE.setNext(outDE);
          prevInDE = null;
        }
        if (firstOutDE == null)
          firstOutDE = outDE;
      }
    }
    if (prevInDE != null) {
      Assert.isTrue(firstOutDE != null);
      prevInDE.setNext(firstOutDE);
    }
  };

  /**
   * Traverses a ring of DirectedEdges, accumulating them into a list. This
   * assumes that all dangling directed edges have been removed from the graph,
   * so that there is always a next dirEdge.
   *
   * @param startDE
   *          the DirectedEdge to start traversing at.
   * @return a List of DirectedEdges that form a ring.
   * @private
   */
  PolygonizeGraph.findDirEdgesInRing = function(startDE) {
    var de = startDE;
    var edges = new ArrayList();
    do {
      edges.add(de);
      de = de.getNext();
      Assert.isTrue(de != null, 'found null DE in ring');
      Assert
          .isTrue(de == startDE || !de.isInRing(), 'found DE already in ring');
    } while (de != startDE);

    return edges;
  };

  /**
   * @private
   */
  PolygonizeGraph.prototype.findEdgeRing = function(startDE) {
    var de = startDE;
    var er = new EdgeRing(this.factory);
    do {
      er.add(de);
      de.setRing(er);
      de = de.getNext();
      Assert.isTrue(de != null, 'found null DE in ring');
      Assert
          .isTrue(de == startDE || !de.isInRing(), 'found DE already in ring');
    } while (de != startDE);

    return er;
  };

  /**
   * Marks all edges from the graph which are "dangles". Dangles are which are
   * incident on a node with degree 1. This process is recursive, since removing
   * a dangling edge may result in another edge becoming a dangle. In order to
   * handle large recursion depths efficiently, an explicit recursion stack is
   * used
   *
   * @return a List containing the {@link LineStrings} that formed dangles.
   */
  PolygonizeGraph.prototype.deleteDangles = function() {
    var nodesToRemove = this.findNodesOfDegree(1);
    var dangleLines = new HashSet();

    var nodeStack = new Stack();
    for (var i = nodesToRemove.iterator(); i.hasNext();) {
      nodeStack.push(i.next());
    }

    while (!nodeStack.isEmpty()) {
      var node = nodeStack.pop();

      PolygonizeGraph.deleteAllEdges(node);
      var nodeOutEdges = node.getOutEdges().getEdges();
      for (var i = nodeOutEdges.iterator(); i.hasNext();) {
        var de = i.next();
        // delete this edge and its sym
        de.setMarked(true);
        var sym = de.getSym();
        if (sym != null)
          sym.setMarked(true);

        // save the line as a dangle
        var e = de.getEdge();
        dangleLines.add(e.getLine());

        var toNode = de.getToNode();
        // add the toNode to the list to be processed, if it is now a dangle
        if (PolygonizeGraph.getDegreeNonDeleted(toNode) == 1)
          nodeStack.push(toNode);
      }
    }
    return dangleLines;
  };

  /**
   * Traverses the polygonized edge rings in the graph and computes the depth
   * parity (odd or even) relative to the exterior of the graph. If the client
   * has requested that the output be polygonally valid, only odd polygons will
   * be constructed.
   *
   */
  PolygonizeGraph.prototype.computeDepthParity = function() {
    while (true) {
      var de = null;
      if (de == null)
        return;
      this.computeDepthParity(de);
    }
  };

  /**
   * Traverses all connected edges, computing the depth parity of the associated
   * polygons.
   *
   * @param de
   * @private
   */
  PolygonizeGraph.prototype.computeDepthParity = function(de) {

  };

  jsts.operation.polygonize.PolygonizeGraph = PolygonizeGraph;

})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

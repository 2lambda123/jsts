<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/geomgraph/GeometryGraph.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/geomgraph/GeometryGraph.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

(function() {

  /**
   * @requires jsts/geom/Location.js
   * @requires jsts/geomgraph/Position.js
   * @requires jsts/geomgraph/PlanarGraph.js
   * @requires jsts/util/Assert.js
   */

  var Location = jsts.geom.Location;
  var Position = jsts.geomgraph.Position;
  var Assert = jsts.util.Assert;



  /**
   * A GeometryGraph is a graph that models a given Geometry
   *
   * @param {int}
   *          argIndex
   * @param {Geometry}
   *          parentGeom
   * @param {BoundaryNodeRule}
   *          boundaryNodeRule
   * @augments jsts.planargraph.PlanarGraph
   */
  jsts.geomgraph.GeometryGraph = function(argIndex, parentGeom,
      boundaryNodeRule) {
    jsts.geomgraph.PlanarGraph.call(this);

    this.lineEdgeMap = new javascript.util.HashMap();

    this.ptLocator = new jsts.algorithm.PointLocator();

    this.argIndex = argIndex;
    this.parentGeom = parentGeom;
    this.boundaryNodeRule = boundaryNodeRule ||
        jsts.algorithm.BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
    if (parentGeom !== null) {
      this.add(parentGeom);
    }
  };

  jsts.geomgraph.GeometryGraph.prototype = new jsts.geomgraph.PlanarGraph();
  jsts.geomgraph.GeometryGraph.constructor = jsts.geomgraph.GeometryGraph;

  /**
   * @return {EdgeSetIntersector}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.createEdgeSetIntersector = function() {
    //return new jsts.geomgraph.index.SimpleEdgeSetIntersector();
    // TODO: use optimized version when ported
    return new jsts.geomgraph.index.SimpleMCSweepLineIntersector();
    //return new jsts.geomgraph.index.SimpleSweepLineIntersector();
  };

  /**
   * @param {BoundaryNodeRule}
   *          boundaryNodeRule
   * @param {int}
   *          boundaryCount
   * @return {int}
   */
  jsts.geomgraph.GeometryGraph.determineBoundary = function(boundaryNodeRule,
      boundaryCount) {
    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY
        : Location.INTERIOR;
  };


  /**
   * @type {Geometry}
   */
  jsts.geomgraph.GeometryGraph.prototype.parentGeom = null;


  /**
   * The lineEdgeMap is a map of the linestring components of the parentGeometry
   * to the edges which are derived from them. This is used to efficiently
   * perform findEdge queries
   *
   * @type {Object}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.lineEdgeMap = null;


  /**
   * @type {BoundaryNodeRule}
   */
  jsts.geomgraph.GeometryGraph.prototype.boundaryNodeRule = null;


  /**
   * If this flag is true, the Boundary Determination Rule will used when
   * deciding whether nodes are in the boundary or not
   */
  /**
   * @type {boolean}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.useBoundaryDeterminationRule = true;


  /**
   * the index of this geometry as an argument to a spatial function (used for
   * labelling)
   *
   * @type {number}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.argIndex = null;


  /**
   * @type {javascript.util.Collection}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.boundaryNodes = null;


  /**
   * @type {Coordinate}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.hasTooFewPoints = false;


  /**
   * @type {Coordinate}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.invalidPoint = null;


  /**
   * @type {PointOnGeometryLocator}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.areaPtLocator = null;


  /**
   * for use if geometry is not Polygonal
   *
   * @type {PointLocator}
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.ptLocator = null;


  jsts.geomgraph.GeometryGraph.prototype.getGeometry = function() {
    return this.parentGeom;
  };

  jsts.geomgraph.GeometryGraph.prototype.getBoundaryNodes = function() {
    if (this.boundaryNodes === null)
      this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex);
    return this.boundaryNodes;
  };

  jsts.geomgraph.GeometryGraph.prototype.getBoundaryNodeRule = function() {
    return this.boundaryNodeRule;
  };



  jsts.geomgraph.GeometryGraph.prototype.findEdge = function(line) {
    return this.lineEdgeMap.get(line);
  };

  jsts.geomgraph.GeometryGraph.prototype.computeSplitEdges = function(edgelist) {
    for (var i = this.edges.iterator(); i.hasNext();) {
      var e = i.next();
      e.eiList.addSplitEdges(edgelist);
    }
  }

  /**
   * @param {Geometry}
   *          g
   */
  jsts.geomgraph.GeometryGraph.prototype.add = function(g) {
    if (g.isEmpty()) {
      return;
    }

    // check if this Geometry should obey the Boundary Determination Rule
    // all collections except MultiPolygons obey the rule
    if (g instanceof jsts.geom.MultiPolygon)
      this.useBoundaryDeterminationRule = false;

    if (g instanceof jsts.geom.Polygon)
      this.addPolygon(g);
    // LineString also handles LinearRings
    else if (g instanceof jsts.geom.LineString)
      this.addLineString(g);
    else if (g instanceof jsts.geom.Point)
      this.addPoint(g);
    else if (g instanceof jsts.geom.MultiPoint)
      this.addCollection(g);
    else if (g instanceof jsts.geom.MultiLineString)
      this.addCollection(g);
    else if (g instanceof jsts.geom.MultiPolygon)
      this.addCollection(g);
    else if (g instanceof jsts.geom.GeometryCollection)
      this.addCollection(g);
    else
      throw new jsts.error.IllegalArgumentError('Geometry type not supported.');
  };


  /**
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addCollection = function(gc) {
    for (var i = 0; i &lt; gc.getNumGeometries(); i++) {
      var g = gc.getGeometryN(i);
      this.add(g);
    }
  };


  /**
   * Add an Edge computed externally. The label on the Edge is assumed to be
   * correct.
   */
  jsts.geomgraph.GeometryGraph.prototype.addEdge = function(e) {
    this.insertEdge(e);
    var coord = e.getCoordinates();
    // insert the endpoint as a node, to mark that it is on the boundary
    this.insertPoint(this.argIndex, coord[0], Location.BOUNDARY);
    this.insertPoint(this.argIndex, coord[coord.length - 1], Location.BOUNDARY);
  };


  /**
   * Add a Point to the graph.
   */
  jsts.geomgraph.GeometryGraph.prototype.addPoint = function(p) {
    var coord = p.getCoordinate();
    this.insertPoint(this.argIndex, coord, Location.INTERIOR);
  };


  /**
   * @param {LineString}
   *          line
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addLineString = function(line) {
    var coord = jsts.geom.CoordinateArrays.removeRepeatedPoints(line
        .getCoordinates());

    if (coord.length &lt; 2) {
      this.hasTooFewPoints = true;
      this.invalidPoint = coord[0];
      return;
    }

    // add the edge for the LineString
    // line edges do not have locations for their left and right sides
    var e = new jsts.geomgraph.Edge(coord, new jsts.geomgraph.Label(
        this.argIndex, Location.INTERIOR));
    this.lineEdgeMap.put(line, e);
    this.insertEdge(e);
    /**
     * Add the boundary points of the LineString, if any. Even if the LineString
     * is closed, add both points as if they were endpoints. This allows for the
     * case that the node already exists and is a boundary point.
     */
    Assert.isTrue(coord.length >= 2, 'found LineString with single point');
    this.insertBoundaryPoint(this.argIndex, coord[0]);
    this.insertBoundaryPoint(this.argIndex, coord[coord.length - 1]);
  };


  /**
   * Adds a polygon ring to the graph. Empty rings are ignored.
   *
   * The left and right topological location arguments assume that the ring is
   * oriented CW. If the ring is in the opposite orientation, the left and right
   * locations must be interchanged.
   *
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addPolygonRing = function(lr, cwLeft,
      cwRight) {
    // don't bother adding empty holes
    if (lr.isEmpty())
      return;

    var coord = jsts.geom.CoordinateArrays.removeRepeatedPoints(lr
        .getCoordinates());

    if (coord.length &lt; 4) {
      this.hasTooFewPoints = true;
      this.invalidPoint = coord[0];
      return;
    }

    var left = cwLeft;
    var right = cwRight;
    if (jsts.algorithm.CGAlgorithms.isCCW(coord)) {
      left = cwRight;
      right = cwLeft;
    }
    var e = new jsts.geomgraph.Edge(coord, new jsts.geomgraph.Label(
        this.argIndex, Location.BOUNDARY, left, right));
    this.lineEdgeMap.put(lr, e);

    this.insertEdge(e);
    // insert the endpoint as a node, to mark that it is on the boundary
    this.insertPoint(this.argIndex, coord[0], Location.BOUNDARY);
  };


  /**
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addPolygon = function(p) {
    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR,
        Location.INTERIOR);

    for (var i = 0; i &lt; p.getNumInteriorRing(); i++) {
      var hole = p.getInteriorRingN(i);

      // Holes are topologically labelled opposite to the shell, since
      // the interior of the polygon lies on their opposite side
      // (on the left, if the hole is oriented CW)
      this.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
    }
  };


  jsts.geomgraph.GeometryGraph.prototype.computeEdgeIntersections = function(g,
      li, includeProper) {
    var si = new jsts.geomgraph.index.SegmentIntersector(li, includeProper,
        true);
    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());

    var esi = this.createEdgeSetIntersector();
    esi.computeIntersections(this.edges, g.edges, si);

    return si;
  };


  /**
   * Compute self-nodes, taking advantage of the Geometry type to minimize the
   * number of intersection tests. (E.g. rings are not tested for
   * self-intersection, since they are assumed to be valid).
   *
   * @param {LineIntersector}
   *          li the LineIntersector to use.
   * @param {boolean}
   *          computeRingSelfNodes if &lt;false>, intersection checks are optimized
   *          to not test rings for self-intersection.
   * @return {SegmentIntersector} the SegmentIntersector used, containing
   *         information about the intersections found.
   */
  jsts.geomgraph.GeometryGraph.prototype.computeSelfNodes = function(li,
      computeRingSelfNodes) {
    var si = new jsts.geomgraph.index.SegmentIntersector(li, true, false);
    var esi = this.createEdgeSetIntersector();
    // optimized test for Polygons and Rings
    if (!computeRingSelfNodes &amp;&amp;
        (this.parentGeom instanceof jsts.geom.LinearRing ||
            this.parentGeom instanceof jsts.geom.Polygon || this.parentGeom instanceof jsts.geom.MultiPolygon)) {
      esi.computeIntersections(this.edges, si, false);
    } else {
      esi.computeIntersections(this.edges, si, true);
    }
    this.addSelfIntersectionNodes(this.argIndex);
    return si;
  };


  /**
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.insertPoint = function(argIndex,
      coord, onLocation) {
    var n = this.nodes.addNode(coord);
    var lbl = n.getLabel();
    if (lbl == null) {
      n.label = new jsts.geomgraph.Label(argIndex, onLocation);
    } else
      lbl.setLocation(argIndex, onLocation);
  };


  /**
   * Adds candidate boundary points using the current {@link BoundaryNodeRule}.
   * This is used to add the boundary points of dim-1 geometries
   * (Curves/MultiCurves).
   */
  jsts.geomgraph.GeometryGraph.prototype.insertBoundaryPoint = function(
      argIndex, coord) {
    var n = this.nodes.addNode(coord);
    var lbl = n.getLabel();
    // the new point to insert is on a boundary
    var boundaryCount = 1;
    // determine the current location for the point (if any)
    var loc = Location.NONE;
    if (lbl !== null)
      loc = lbl.getLocation(argIndex, Position.ON);
    if (loc === Location.BOUNDARY)
      boundaryCount++;

    // determine the boundary status of the point according to the Boundary
    // Determination Rule
    var newLoc = jsts.geomgraph.GeometryGraph.determineBoundary(
        this.boundaryNodeRule, boundaryCount);
    lbl.setLocation(argIndex, newLoc);
  };


  /**
   * add edge intersections as self intersections from each edge intersection
   * list
   *
   * @param argIndex
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addSelfIntersectionNodes = function(
      argIndex) {
    for (var i = this.edges.iterator(); i.hasNext();) {
      var e = i.next();
      var eLoc = e.getLabel().getLocation(argIndex);
      for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {
        var ei = eiIt.next();
        this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
      }
    }
  };


  /**
   * Add a node for a self-intersection. If the node is a potential boundary
   * node (e.g. came from an edge which is a boundary) then insert it as a
   * potential boundary node. Otherwise, just add it as a regular node.
   *
   * @private
   */
  jsts.geomgraph.GeometryGraph.prototype.addSelfIntersectionNode = function(
      argIndex, coord, loc) {
    // if this node is already a boundary node, don't change it
    if (this.isBoundaryNode(argIndex, coord))
      return;
    if (loc === Location.BOUNDARY &amp;&amp; this.useBoundaryDeterminationRule)
      this.insertBoundaryPoint(argIndex, coord);
    else
      this.insertPoint(argIndex, coord, loc);
  };

  jsts.geomgraph.GeometryGraph.prototype.getInvalidPoint = function() {
    return this.invalidPoint;
  };

})();

// TODO: port rest of class
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

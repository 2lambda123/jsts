<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/operation/distance/DistanceOp.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/operation/distance/DistanceOp.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */
/**
 * Find two points on two {@link Geometry}s which lie
 * within a given distance, or else are the nearest points
 * on the geometries (in which case this also
 * provides the distance between the geometries).
 * &lt;p>
 * The distance computation also finds a pair of points in the input geometries
 * which have the minimum distance between them.
 * If a point lies in the interior of a line segment,
 * the coordinate computed is a close
 * approximation to the exact point.
 * &lt;p>
 * The algorithms used are straightforward O(n^2)
 * comparisons.  This worst-case performance could be improved on
 * by using Voronoi techniques or spatial indexes.
 *
 */



/**
 * Constructs a DistanceOp that computes the distance and nearest points
 * between the two specified geometries.
 *
 * @param {Geometry}
 *          g0 a Geometry.
 * @param {Geometry}
 *          g1 a Geometry.
 * @param {double}
 *          terminateDistance the distance on which to terminate the search.
 * @constructor
 */
jsts.operation.distance.DistanceOp = function(g0, g1, terminateDistance) {
  this.ptLocator = new jsts.algorithm.PointLocator();

  this.geom = [];
  this.geom[0] = g0;
  this.geom[1] = g1;
  this.terminateDistance = terminateDistance;
};


/**
 * @type {Geometry[]}
 */
jsts.operation.distance.DistanceOp.prototype.geom = null;


/**
 * @type {double}
 */
jsts.operation.distance.DistanceOp.prototype.terminateDistance = 0.0;


/**
 * @type {PointLocator}
 */
jsts.operation.distance.DistanceOp.prototype.ptLocator = null;


/**
 * @type {GeometryLocation[]}
 */
jsts.operation.distance.DistanceOp.prototype.minDistanceLocation = null;


/**
 * @type {double}
 */
jsts.operation.distance.DistanceOp.prototype.minDistance = Number.MAX_VALUE;


/**
 * Compute the distance between the nearest points of two geometries.
 *
 * @param {Geometry}
 *          g0 a {@link Geometry}.
 * @param {Geometry}
 *          g1 another {@link Geometry}.
 * @return {double} the distance between the geometries.
 */
jsts.operation.distance.DistanceOp.distance = function(g0, g1) {
  var distOp = new jsts.operation.distance.DistanceOp(g0, g1, 0.0);
  return distOp.distance();
};


/**
 * Test whether two geometries lie within a given distance of each other.
 *
 * @param {Geometry}
 *          g0 a {@link Geometry}.
 * @param {Geometry}
 *          g1 another {@link Geometry}.
 * @param {double}
 *          distance the distance to test.
 * @return {boolean} true if g0.distance(g1) &lt;= distance.
 */
jsts.operation.distance.DistanceOp.isWithinDistance = function(g0, g1,
    distance) {
  var distOp = new jsts.operation.distance.DistanceOp(g0, g1, distance);
  return distOp.distance() &lt;= distance;
};


/**
 * Compute the the nearest points of two geometries. The points are presented
 * in the same order as the input Geometries.
 *
 * @param {Geometry}
 *          g0 a {@link Geometry}.
 * @param {Geometry}
 *          g1 another {@link Geometry}.
 * @return {Coordinate[]} the nearest points in the geometries.
 */
jsts.operation.distance.DistanceOp.nearestPoints = function(g0, g1) {
  var distOp = new jsts.operation.distance.DistanceOp(g0, g1, 0.0);
  return distOp.nearestPoints();
};


/**
 * Report the distance between the nearest points on the input geometries.
 *
 * @return {double} the distance between the geometries.
 * @return {double} 0 if either input geometry is empty.
 * @throws IllegalArgumentException
 *           if either input geometry is null
 */
jsts.operation.distance.DistanceOp.prototype.distance = function() {
  if (this.geom[0] === null || this.geom[1] === null)
    throw new jsts.error.IllegalArgumentError('null geometries are not supported');
  if (this.geom[0].isEmpty() || this.geom[1].isEmpty())
    return 0.0;

  this.computeMinDistance();
  return this.minDistance;
};


/**
 * Report the coordinates of the nearest points in the input geometries. The
 * points are presented in the same order as the input Geometries.
 *
 * @return {Coordinate[] } a pair of {@link Coordinate} s of the nearest
 *         points.
 */
jsts.operation.distance.DistanceOp.prototype.nearestPoints = function() {
  this.computeMinDistance();
  var nearestPts = [this.minDistanceLocation[0].getCoordinate(),
                    this.minDistanceLocation[1].getCoordinate()];
  return nearestPts;
};


/**
 * Report the locations of the nearest points in the input geometries. The
 * locations are presented in the same order as the input Geometries.
 *
 * @return {GeometryLocation[] } a pair of {@link GeometryLocation} s for the
 *         nearest points.
 */
jsts.operation.distance.DistanceOp.prototype.nearestLocations = function() {
  this.computeMinDistance();
  return this.minDistanceLocation;
};


/**
 * @param {GeometryLocation[]}
 *          locGeom locations.
 * @param {boolean}
 *          flip if locations should be flipped.
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.updateMinDistance = function(
    locGeom, flip) {
  // if not set then don't update
  if (locGeom[0] === null)
    return;

  if (flip) {
    this.minDistanceLocation[0] = locGeom[1];
    this.minDistanceLocation[1] = locGeom[0];
  } else {
    this.minDistanceLocation[0] = locGeom[0];
    this.minDistanceLocation[1] = locGeom[1];
  }
};


/**
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistance = function() {
  // overloaded variant
  if (arguments.length > 0) {
    this.computeMinDistance2.apply(this, arguments);
    return;
  }

  // only compute once!
  if (this.minDistanceLocation !== null)
    return;

  this.minDistanceLocation = [];
  this.computeContainmentDistance();
  if (this.minDistance &lt;= this.terminateDistance)
    return;
  this.computeFacetDistance();
};


/**
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance = function() {
  if (arguments.length === 2) {
    this.computeContainmentDistance2.apply(this, arguments);
    return;
  } else if (arguments.length === 3 &amp;&amp; (!arguments[0] instanceof jsts.operation.distance.GeometryLocation)) {
    this.computeContainmentDistance3.apply(this, arguments);
    return;
  } else if (arguments.length === 3) {
    this.computeContainmentDistance4.apply(this, arguments);
    return;
  }

  var locPtPoly = [];
  // test if either geometry has a vertex inside the other
  this.computeContainmentDistance2(0, locPtPoly);
  if (this.minDistance &lt;= this.terminateDistance)
    return;
  this.computeContainmentDistance2(1, locPtPoly);
};


/**
 * @param {int}
 *          polyGeomIndex
 * @param {GeometryLocation[]}
 *          locPtPoly
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance2 = function(
    polyGeomIndex, locPtPoly) {

  var locationsIndex = 1 - polyGeomIndex;
  var polys = jsts.geom.util.PolygonExtracter.getPolygons(this.geom[polyGeomIndex]);
  if (polys.length > 0) {
    var insideLocs = jsts.operation.distance.ConnectedElementLocationFilter
        .getLocations(this.geom[locationsIndex]);
    this.computeContainmentDistance3(insideLocs, polys, locPtPoly);
    if (this.minDistance &lt;= this.terminateDistance) {
      // this assigment is determined by the order of the args in the
      // computeInside call above
      this.minDistanceLocation[locationsIndex] = locPtPoly[0];
      this.minDistanceLocation[polyGeomIndex] = locPtPoly[1];
      return;
    }
  }
};


/**
 * @param {[]}
 *          locs
 * @param {[]}
 *          polys
 * @param {GeometryLocation[] }
 *          locPtPoly
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance3 = function(
    locs, polys, locPtPoly) {

  for (var i = 0; i &lt; locs.length; i++) {
    var loc = locs[i];
    for (var j = 0; j &lt; polys.length; j++) {
      this.computeContainmentDistance4(loc, polys[j], locPtPoly);
      if (this.minDistance &lt;= this.terminateDistance)
        return;
    }
  }
};


/**
 * @param {GeometryLocation}
 *          ptLoc
 * @param {Polygon}
 *          poly
 * @param {GeometryLocation[]} locPtPoly
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeContainmentDistance4 = function(
    ptLoc, poly, locPtPoly) {
  var pt = ptLoc.getCoordinate();
  // if pt is not in exterior, distance to geom is 0
  if (jsts.geom.Location.EXTERIOR !== this.ptLocator.locate(pt, poly)) {
    this.minDistance = 0.0;
    locPtPoly[0] = ptLoc;
    locPtPoly[1] = new jsts.operation.distance.GeometryLocation(poly, pt);
    return;
  }
};


/**
 * Computes distance between facets (lines and points) of input geometries.
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeFacetDistance = function() {
  var locGeom = [];

  /**
   * Geometries are not wholely inside, so compute distance from lines and
   * points of one to lines and points of the other
   */
  var lines0 = jsts.geom.util.LinearComponentExtracter.getLines(this.geom[0]);
  var lines1 = jsts.geom.util.LinearComponentExtracter.getLines(this.geom[1]);

  var pts0 = jsts.geom.util.PointExtracter.getPoints(this.geom[0]);
  var pts1 = jsts.geom.util.PointExtracter.getPoints(this.geom[1]);

  // exit whenever minDistance goes LE than terminateDistance
  this.computeMinDistanceLines(lines0, lines1, locGeom);
  this.updateMinDistance(locGeom, false);
  if (this.minDistance &lt;= this.terminateDistance)
    return;

  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
  this.updateMinDistance(locGeom, false);
  if (this.minDistance &lt;= this.terminateDistance)
    return;

  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
  this.updateMinDistance(locGeom, true);
  if (this.minDistance &lt;= this.terminateDistance)
    return;

  locGeom[0] = null;
  locGeom[1] = null;
  this.computeMinDistancePoints(pts0, pts1, locGeom);
  this.updateMinDistance(locGeom, false);
};


/**
 * @param {[]}
 *          lines0.
 * @param {[]}
 *          lines1
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistanceLines = function(
    lines0, lines1, locGeom) {
  for (var i = 0; i &lt; lines0.length; i++) {
    var line0 = lines0[i];
    for (var j = 0; j &lt; lines1.length; j++) {
      var line1 = lines1[j];
      this.computeMinDistance(line0, line1, locGeom);
      if (this.minDistance &lt;= this.terminateDistance)
        return;
    }
  }
};


/**
 * @param {[]}
 *          points0
 * @param {[]}
 *          points1
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistancePoints = function(
    points0, points1, locGeom) {
  for (var i = 0; i &lt; points0.length; i++) {
    var pt0 = points0[i];
    for (var j = 0; j &lt; points1.length; j++) {
      var pt1 = points1[j];
      var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
      if (dist &lt; this.minDistance) {
        this.minDistance = dist;
        locGeom[0] = new jsts.operation.distance.GeometryLocation(pt0, 0, pt0.getCoordinate());
        locGeom[1] = new jsts.operation.distance.GeometryLocation(pt1, 0, pt1.getCoordinate());
      }
      if (this.minDistance &lt;= this.terminateDistance)
        return;
    }
  }
};


/**
 * @param {[]}
 *          lines
 * @param {[]}
 *          points
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistanceLinesPoints = function(
    lines, points, locGeom) {
  for (var i = 0; i &lt; lines.length; i++) {
    var line = lines[i];
    for (var j = 0; j &lt; points.length; j++) {
      var pt = points[j];
      this.computeMinDistance(line, pt, locGeom);
      if (this.minDistance &lt;= this.terminateDistance)
        return;
    }
  }
};


/**
 * @param {LineString}
 *          line0
 * @param {Point}
 *          line1
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistance2 = function(
    line0, line1, locGeom) {

  // overloaded variant
  if (line1 instanceof jsts.geom.Point) {
    this.computeMinDistance3(line0, line1, locGeom);
    return;
  }

  if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this.minDistance) {
    return;
  }
  var coord0 = line0.getCoordinates();
  var coord1 = line1.getCoordinates();
  // brute force approach!
  for (var i = 0; i &lt; coord0.length - 1; i++) {
    for (var j = 0; j &lt; coord1.length - 1; j++) {
      var dist = jsts.algorithm.CGAlgorithms.distanceLineLine(coord0[i], coord0[i + 1],
          coord1[j], coord1[j + 1]);
      if (dist &lt; this.minDistance) {
        this.minDistance = dist;
        var seg0 = new jsts.geom.LineSegment(coord0[i], coord0[i + 1]);
        var seg1 = new jsts.geom.LineSegment(coord1[j], coord1[j + 1]);
        var closestPt = seg0.closestPoints(seg1);
        locGeom[0] = new jsts.operation.distance.GeometryLocation(line0, i, closestPt[0]);
        locGeom[1] = new jsts.operation.distance.GeometryLocation(line1, j, closestPt[1]);
      }
      if (this.minDistance &lt;= this.terminateDistance) {
        return;
      }
    }
  }
};


/**
 * @param {LineString}
 *          line
 * @param {Point}
 *          pt
 * @param {GeometryLocation[]}
 *          locGeom
 * @private
 */
jsts.operation.distance.DistanceOp.prototype.computeMinDistance3 = function(
    line, pt, locGeom) {
  if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this.minDistance) {
    return;
  }
  var coord0 = line.getCoordinates();
  var coord = pt.getCoordinate();
  // brute force approach!
  for (var i = 0; i &lt; coord0.length - 1; i++) {
    var dist = jsts.algorithm.CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);
    if (dist &lt; this.minDistance) {
      this.minDistance = dist;
      var seg = new jsts.geom.LineSegment(coord0[i], coord0[i + 1]);
      var segClosestPoint = seg.closestPoint(coord);
      locGeom[0] = new jsts.operation.distance.GeometryLocation(line, i, segClosestPoint);
      locGeom[1] = new jsts.operation.distance.GeometryLocation(pt, 0, coord);
    }
    if (this.minDistance &lt;= this.terminateDistance) {
      return;
    }
  }
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

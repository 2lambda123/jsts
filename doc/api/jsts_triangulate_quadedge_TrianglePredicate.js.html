<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/triangulate/quadedge/TrianglePredicate.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/triangulate/quadedge/TrianglePredicate.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */



/**
 * Algorithms for computing values and predicates associated with triangles.
 *
 * For some algorithms extended-precision implementations are provided, which
 * are more robust (i.e. they produce correct answers in more cases). Also, some
 * more robust formulations of some algorithms are provided, which utilize
 * normalization to the origin.
 *
 * @constructor
 */
jsts.triangulate.quadedge.TrianglePredicate = function() {

};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. This
 * test uses simple double-precision arithmetic, and thus may not be robust.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleNonRobust = function(a,
    b, c, p) {
  var isInCircle = (a.x * a.x + a.y * a.y) *
      jsts.triangulate.quadedge.TrianglePredicate.triArea(b, c, p) -
      (b.x * b.x + b.y * b.y) *
      jsts.triangulate.quadedge.TrianglePredicate.triArea(a, c, p) +
      (c.x * c.x + c.y * c.y) *
      jsts.triangulate.quadedge.TrianglePredicate.triArea(a, b, p) -
      (p.x * p.x + p.y * p.y) *
      jsts.triangulate.quadedge.TrianglePredicate.triArea(a, b, c) > 0;

  return isInCircle;
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. This
 * test uses simple double-precision arithmetic, and thus is not 10% robust.
 * However, by using normalization to the origin it provides improved robustness
 * and increased performance.
 * &lt;p>
 * Based on code by J.R.Shewchuk.
 *
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleNormalized = function(a,
    b, c, p) {
  var adx, ady, bdx, bdy, cdx, cdy, abdet, bcdet, cadet, alift, blift, clift, disc;

  adx = a.x - p.x;
  ady = a.y - p.y;
  bdx = b.x - p.x;
  bdy = b.y - p.y;
  cdx = c.x - p.x;
  cdy = c.y - p.y;

  abdet = adx * bdy - bdx * ady;
  bcdet = bdx * cdy - cdx * bdy;
  cadet = cdx * ady - adx * cdy;
  alift = adx * adx + ady * ady;
  blift = bdx * bdx + bdy * bdy;
  clift = cdx * cdx + cdy * cdy;

  disc = alift * bcdet + blift * cadet + clift * abdet;
  return disc > 0;
};


/**
 * Computes twice the area of the oriented triangle (a, b, c), i.e. the area is
 * positive if the triangle is oriented counterclockwise.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @return {Number} The calculated area.
 */
jsts.triangulate.quadedge.TrianglePredicate.triArea = function(a, b, c) {
  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. This
 * method uses more robust computation.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleRobust = function(a, b,
    c, p) {
  return jsts.triangulate.quadedge.TrianglePredicate.isInCircleNormalized(a, b,
      c, p);
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. The
 * computation uses {@link DD} arithmetic for robustness.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDSlow = function(a, b,
    c, p) {
  var px, py, ax, ay, bx, by, cx, cy, aTerm, bTerm, cTerm, pTerm, sum, isInCircle;

  px = jsts.math.DD.valueOf(p.x);
  py = jsts.math.DD.valueOf(p.y);
  ax = jsts.math.DD.valueOf(a.x);
  ay = jsts.math.DD.valueOf(a.y);
  bx = jsts.math.DD.valueOf(b.x);
  by = jsts.math.DD.valueOf(b.y);
  cx = jsts.math.DD.valueOf(c.x);
  cy = jsts.math.DD.valueOf(c.y);

  aTerm = (ax.multiply(ax).add(ay.multiply(ay)))
      .multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(bx,
          by, cx, cy, px, py));
  bTerm = (bx.multiply(bx).add(by.multiply(by)))
      .multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,
          ay, cx, cy, px, py));
  cTerm = (cx.multiply(cx).add(cy.multiply(cy)))
      .multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,
          ay, bx, by, px, py));
  pTerm = (px.multiply(px).add(py.multiply(py)))
      .multiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow(ax,
          ay, bx, by, cx, cy));

  sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);
  isInCircle = sum.doubleValue() > 0;

  return isInCircle;
};


/**
 * Computes twice the area of the oriented triangle (a, b, c), i.e., the area is
 * positive if the triangle is oriented counterclockwise. The computation uses
 * {@link DD} arithmetic for robustness.
 *
 * @param {jsts.math.DD}
 *          ax the x ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          ay the y ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          bx the x ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          by the y ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          cx the x ordinate of a vertex of the triangle.
 * @param {jsts.math.DD}
 *          cy the y ordinate of a vertex of the triangle.
 * @return {jsts.math.DD} The calculated area.
 */
jsts.triangulate.quadedge.TrianglePredicate.triAreaDDSlow = function(ax, ay,
    bx, by, cx, cy) {
  return (bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay)
      .multiply(cx.subtract(ax))));
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. The
 * computation uses {@link DD} arithmetic for robustness.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDFast = function(a, b,
    c, p) {
  var aTerm, bTerm, cTerm, pTerm, sum, isInCircle;

  aTerm = (jsts.math.DD.sqr(a.x).selfAdd(jsts.math.DD.sqr(a.y)))
      .selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(
          b, c, p));
  bTerm = (jsts.math.DD.sqr(b.x).selfAdd(jsts.math.DD.sqr(b.y)))
      .selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(
          a, c, p));
  cTerm = (jsts.math.DD.sqr(c.x).selfAdd(jsts.math.DD.sqr(c.y)))
      .selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(
          a, b, p));
  pTerm = (jsts.math.DD.sqr(p.x).selfAdd(jsts.math.DD.sqr(p.y)))
      .selfMultiply(jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast(
          a, b, c));

  sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);
  isInCircle = sum.doubleValue() > 0;

  return isInCircle;
};


/**
 * Computes twice the area of the oriented triangle (a, b, c), i.e., the area is
 * positive if the triangle is oriented counterclockwise. The computation uses
 * {@link DD} arithmetic for robustness.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex in the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex in the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex in the triangle.
 * @return {jsts.math.DD} The calculated area.
 */
jsts.triangulate.quadedge.TrianglePredicate.triAreaDDFast = function(a, b, c) {
  var t1, t2;

  t1 = jsts.math.DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(
      jsts.math.DD.valueOf(c.y).selfSubtract(a.y));

  t2 = jsts.math.DD.valueOf(b.y).selSubtract(a.y).selfMultiply(
      jsts.math.DD.valueOf(c.x).selfSubtract(a.x));

  return t1.selfSubtract(t2);
};


/**
 * Tests if a point is inside the circle defined by the points a, b, c. This
 * test uses double-double precision arithmetic.
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleDDNormalized = function(
    a, b, c, p) {
  var adx, ady, bdx, bdy, cdx, cdy, abdet, bcdet, cadet, alift, blift, clift, sum, isInCircle;

  adx = jsts.math.DD.valueOf(a.x).selfSubtract(p.x);
  ady = jsts.math.DD.valueOf(a.y).selfSubtract(p.y);
  bdx = jsts.math.DD.valueOf(b.x).selfSubtract(p.x);
  bdx = jsts.math.DD.valueOf(b.y).selfSubtract(p.y);
  cdx = jsts.math.DD.valueOf(c.x).selfSubtract(p.x);
  cdx = jsts.math.DD.valueOf(c.y).selfSubtract(p.y);

  abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));
  bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));
  cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));
  alift = adx.multiply(adx).selfAdd(ady.multiply(ady));
  blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));
  clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));

  sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(
      clift.selfMultiply(abdet));

  isInCircle = sum.doubleValue() > 0;

  return isInCircle;
};


/**
 * Computes the inCircle test using distance from the circumcentre. Uses
 * standard double-precision arithmetic.
 * &lt;p>
 * In general this doesn't appear to be any more robust than the standard
 * calculation. However, there is at least one case where the test point is far
 * enough from the circumcircle that this test gives the correct answer.
 *
 * &lt;pre>
 * LINESTRING
 * (1507029.9878 518325.7547, 1507022.1120341457 518332.8225183258,
 * 1507029.9833 518325.7458, 1507029.9896965567 518325.744909031)
 * &lt;/pre>
 *
 * @param {jsts.geom.Coordinate}
 *          a a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          b a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          c a vertex of the triangle.
 * @param {jsts.geom.Coordinate}
 *          p the point to test.
 * @return {Boolean} true if this point is inside the circle defined by the
 *         points a, b, c.
 */
jsts.triangulate.quadedge.TrianglePredicate.isInCircleCC = function(a, b, c, p) {
  var cc, ccRadius, pRadiusDiff;

  cc = jsts.geom.Triangle.circumcentre(a, b, c);
  ccRadius = a.distance(cc);
  pRadiusDiff = p.distance(cc) - ccRadius;

  return pRadiusDiff &lt;= 0;
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

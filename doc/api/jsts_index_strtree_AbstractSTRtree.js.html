<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsts/index/strtree/AbstractSTRtree.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsts/index/strtree/AbstractSTRtree.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2011 by The Authors.
 * Published under the LGPL 2.1 license.
 * See /license-notice.txt for the full text of the license notice.
 * See /license.txt for the full text of the license.
 */

/**
 * Base class for STRtree and SIRtree. STR-packed R-trees are described in:
 * P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
 * Application To GIS. Morgan Kaufmann, San Francisco, 2002.
 * &lt;p>
 * This implementation is based on Boundables rather than just AbstractNodes,
 * because the STR algorithm operates on both nodes and
 * data, both of which are treated here as Boundables.
 *
 * @see STRtree
 * @see SIRtree
 */



/**
 * Constructs an AbstractSTRtree with the specified maximum number of child
 * nodes that a node may have
 *
 * @param {Integer}
 *          nodeCapacity
 *
 * @constuctor
 */
jsts.index.strtree.AbstractSTRtree = function(nodeCapacity) {
  if (nodeCapacity === undefined)
    return;

  this.itemBoundables = [];

  jsts.util.Assert.isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1');
  this.nodeCapacity = nodeCapacity;
};



/**
 * A test for intersection between two bounds, necessary because subclasses of
 * AbstractSTRtree have different implementations of bounds.
 *
 * @interface
 * @constructor
 * @public
 */
jsts.index.strtree.AbstractSTRtree.IntersectsOp = function() {

};


/**
 * For STRtrees, the bounds will be Envelopes; for SIRtrees, Intervals; for
 * other subclasses of AbstractSTRtree, some other class.
 *
 * @param {Object}
 *          aBounds the bounds of one spatial object.
 * @param {Object}
 *          bBounds the bounds of another spatial object.
 * @return {boolean} whether the two bounds intersect.
 */
jsts.index.strtree.AbstractSTRtree.IntersectsOp.prototype.intersects = function(
    aBounds, bBounds) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * @type {jsts.index.strtree.AbstractNode}
 * @protected
 */
jsts.index.strtree.AbstractSTRtree.prototype.root = null;


/**
 * @type {boolean}
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.built = false;


/**
 * @type {Array}
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.itemBoundables = null;


/**
 * @type {number}
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.nodeCapacity = null;


/**
 * Creates parent nodes, grandparent nodes, and so forth up to the root node,
 * for the data that has been inserted into the tree. Can only be called once,
 * and thus can be called only after all of the data has been inserted into the
 * tree.
 */
jsts.index.strtree.AbstractSTRtree.prototype.build = function() {
  jsts.util.Assert.isTrue(!this.built);
  this.root = this.itemBoundables.length === 0 ? this.createNode(0) : this
      .createHigherLevels(this.itemBoundables, -1);
  this.built = true;
};


/**
 * @param {number}
 *          level
 * @return {jsts.index.strtree.AbstractNode}
 */
jsts.index.strtree.AbstractSTRtree.prototype.createNode = function(level) {
  throw new jsts.error.AbstractMethodInvocationError();
};


/**
 * Sorts the childBoundables then divides them into groups of size M, where M is
 * the node capacity.
 */
jsts.index.strtree.AbstractSTRtree.prototype.createParentBoundables = function(
    childBoundables, newLevel) {
  jsts.util.Assert.isTrue(!(childBoundables.length === 0));
  var parentBoundables = [];
  parentBoundables.push(this.createNode(newLevel));
  var sortedChildBoundables = [];
  for (var i = 0; i &lt; childBoundables.length; i++) {
    sortedChildBoundables.push(childBoundables[i]);
  }
  sortedChildBoundables.sort(this.getComparator());
  for (var i = 0; i &lt; sortedChildBoundables.length; i++) {
    var childBoundable = sortedChildBoundables[i];
    if (this.lastNode(parentBoundables).getChildBoundables().length === this
        .getNodeCapacity()) {
      parentBoundables.push(this.createNode(newLevel));
    }
    this.lastNode(parentBoundables).addChildBoundable(childBoundable);
  }
  return parentBoundables;
};


/**
 * @param {Array}
 *          nodes
 * @return {jsts.index.strtree.AbstractNode}
 */
jsts.index.strtree.AbstractSTRtree.prototype.lastNode = function(nodes) {
  return nodes[nodes.length - 1];
};


/**
 * @param {number}
 *          a
 * @param {number}
 *          b
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.compareDoubles = function(a, b) {
  return a > b ? 1 : a &lt; b ? -1 : 0;
};


/**
 * Creates the levels higher than the given level
 *
 * @param {Array}
 *          boundablesOfALevel the level to build on.
 * @param {number}
 *          level the level of the Boundables, or -1 if the boundables are item
 *          boundables (that is, below level 0).
 * @return {jsts.index.strtree.AbstractNode} the root, which may be a ParentNode
 *         or a LeafNode.
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.createHigherLevels = function(
    boundablesOfALevel, level) {
  jsts.util.Assert.isTrue(!(boundablesOfALevel.length === 0));
  var parentBoundables = this.createParentBoundables(boundablesOfALevel,
      level + 1);
  if (parentBoundables.length === 1) {
    return parentBoundables[0];
  }
  return this.createHigherLevels(parentBoundables, level + 1);
};


/**
 * @return {jsts.index.strtree.AbstractNode}
 */
jsts.index.strtree.AbstractSTRtree.prototype.getRoot = function() {
  if (!this.built)
    this.build();
  return this.root;
};


/**
 * Returns the maximum number of child nodes that a node may have
 *
 * return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.getNodeCapacity = function() {
  return this.nodeCapacity;
};


/**
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.size = function() {
  if (arguments.length === 1) {
    return this.size2(arguments[0]);
  }

  if (!this.built) {
    this.build();
  }
  if (this.itemBoundables.length === 0) {
    return 0;
  }
  return this.size2(root);
};

/**
 * @param {jsts.index.strtree.AbstractNode=}
 *          [node].
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.size2 = function(node) {
  var size = 0;
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i &lt; childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      size += this.size(childBoundable);
    } else if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      size += 1;
    }
  }
  return size;
};


/**
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.depth = function() {
  if (arguments.length === 1) {
    return this.depth2(arguments[0]);
  }

  if (!this.built) {
    this.build();
  }
  if (this.itemBoundables.length === 0) {
    return 0;
  }
  return this.depth2(root);
};

/**
 * @param {jsts.index.strtree.AbstractNode}
 *          [node].
 * @return {number}
 */
jsts.index.strtree.AbstractSTRtree.prototype.depth2 = function() {
  var maxChildDepth = 0;
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i &lt; childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      var childDepth = this.depth(childBoundable);
      if (childDepth > maxChildDepth)
        maxChildDepth = childDepth;
    }
  }
  return maxChildDepth + 1;
};


/**
 *
 * @param {Object}
 *          bounds
 * @param {Object}
 *          item
 */
jsts.index.strtree.AbstractSTRtree.prototype.insert = function(bounds, item) {
  jsts.util.Assert.isTrue(!this.built, 'Cannot insert items into an STR packed R-tree after it has been built.');
  this.itemBoundables.push(new jsts.index.strtree.ItemBoundable(bounds, item));
};

/**
 * Also builds the tree, if necessary.
 *
 * @param {Object}
 *          searchBounds
 * @param {jsts.index.ItemVisitor}
 *          [visitor].
 * @param {jsts.index.strtree.AbstractNode}
 *          [node].
 * @param {Array}
 *          [matches].
 * @return {Array}
 */
jsts.index.strtree.AbstractSTRtree.prototype.query = function(searchBounds) {
  if (arguments.length > 1) {
    this.query2.apply(this, arguments);
  }

  if (!this.built) {
    this.build();
  }
  var matches = [];
  if (this.itemBoundables.length === 0) {
    jsts.util.Assert.isTrue(this.root.getBounds() === null);
    return matches;
  }
  if (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {
    this.query3(searchBounds, this.root, matches);
  }
  return matches;
};

jsts.index.strtree.AbstractSTRtree.prototype.query2 = function(searchBounds,
    visitor) {
  if (arguments.length > 2) {
    this.query3.apply(this, arguments);
  }

  if (!this.built) {
    this.build();
  }
  if (this.itemBoundables.length === 0) {
    jsts.util.Assert.isTrue(this.root.getBounds() === null);
  }
  if (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {
    this.query4(searchBounds, this.root, visitor);
  }
};

/**
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.query3 = function(searchBounds,
    node, matches) {
  if (!(arguments[2] instanceof Array)) {
    this.query4.apply(this, arguments);
  }

  var childBoundables = node.getChildBoundables();
  for (var i = 0; i &lt; childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (!this.getIntersectsOp().intersects(childBoundable.getBounds(),
        searchBounds)) {
      continue;
    }
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      this.query3(searchBounds, childBoundable, matches);
    } else if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      matches.push(childBoundable.getItem());
    } else {
      jsts.util.Assert.shouldNeverReachHere();
    }
  }
};

/**
 * @private
 */
jsts.index.strtree.AbstractSTRtree.prototype.query4 = function(searchBounds,
    node, visitor) {
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i &lt; childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (!this.getIntersectsOp().intersects(childBoundable.getBounds(),
        searchBounds)) {
      continue;
    }
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      this.query4(searchBounds, childBoundable, visitor);
    } else if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      visitor.visitItem(childBoundable.getItem());
    } else {
      jsts.util.Assert.shouldNeverReachHere();
    }
  }
};

/**
 * @return {jsts.index.strtree.AbstractSTRtree.IntersectOp}
 */
jsts.index.strtree.AbstractSTRtree.prototype.getIntersectsOp = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};

// TODO: port rest

/**
 * Gets a tree structure (as a nested list) corresponding to the structure of
 * the items and nodes in this tree.
 * &lt;p>
 * The returned {@link List}s contain either {@link Object} items, or Lists
 * which correspond to subtrees of the tree Subtrees which do not contain any
 * items are not included.
 * &lt;p>
 * Builds the tree if necessary.
 *
 * @return {Array} a List of items and/or Lists.
 */
jsts.index.strtree.AbstractSTRtree.prototype.itemsTree = function() {
  if (arguments.length === 1) {
    return this.itemsTree2.apply(this, arguments);
  }

  if (!this.built) {
    this.build();
  }

  var valuesTree = this.itemsTree2(this.root);
  if (valuesTree === null)
    return [];
  return valuesTree;
};

jsts.index.strtree.AbstractSTRtree.prototype.itemsTree2 = function(node) {
  var valuesTreeForNode = [];
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i &lt; childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      var valuesTreeForChild = this.itemsTree(childBoundable);
      // only add if not null (which indicates an item somewhere in this tree
      if (valuesTreeForChild != null)
        valuesTreeForNode.push(valuesTreeForChild);
    } else if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      valuesTreeForNode.push(childBoundable.getItem());
    } else {
      jsts.util.Assert.shouldNeverReachHere();
    }
  }
  if (valuesTreeForNode.length &lt;= 0)
    return null;
  return valuesTreeForNode;
};

/**
 * Removes an item from the tree. (Builds the tree, if necessary.)
 *
 * @param {Object}
 *          searchBounds
 * @param {jsts.index.strtree.AbstractNode}
 *          [node].
 * @param {Object]
 *          item}
 * @return {boolean}
 */
jsts.index.strtree.AbstractSTRtree.prototype.remove = function(searchBounds,
    item) {
  // TODO: argument switch


  if (!this.built) {
    this.build();
  }
  if (this.itemBoundables.length === 0) {
    jsts.util.Assert.isTrue(this.root.getBounds() == null);
  }
  if (this.getIntersectsOp().intersects(this.root.getBounds(), searchBounds)) {
    return this.remove2(searchBounds, this.root, item);
  }
  return false;
};

jsts.index.strtree.AbstractSTRtree.prototype.remove2 = function(searchBounds,
    node, item) {
  // first try removing item from this node
  var found = this.removeItem(node, item);
  if (found)
    return true;

  var childToPrune = null;
  // next try removing item from lower nodes
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i &lt; childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (!this.getIntersectsOp().intersects(childBoundable.getBounds(),
        searchBounds)) {
      continue;
    }
    if (childBoundable instanceof jsts.index.strtree.AbstractNode) {
      found = this.remove(searchBounds, childBoundable, item);
      // if found, record child for pruning and exit
      if (found) {
        childToPrune = childBoundable;
        break;
      }
    }
  }
  // prune child if possible
  if (childToPrune != null) {
    if (childToPrune.getChildBoundables().length === 0) {
      childBoundables.splice(childBoundables.indexOf(childToPrune), 1);
    }
  }
  return found;
};



/**
 *
 * @param {jsts.index.strtree.AbstractNode}
 *          node
 * @param {Object}
 *          item
 * @return {boolean}
 */
jsts.index.strtree.AbstractSTRtree.prototype.removeItem = function(node, item) {
  var childToRemove = null;
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i &lt; childBoundables.length; i++) {
    var childBoundable = childBoundables[i];
    if (childBoundable instanceof jsts.index.strtree.ItemBoundable) {
      if (childBoundable.getItem() === item)
        childToRemove = childBoundable;
    }
  }
  if (childToRemove !== null) {
    childBoundables.splice(childBoundables.indexOf(childToRemove), 1);
    return true;
  }
  return false;
};


jsts.index.strtree.AbstractSTRtree.prototype.boundablesAtLevel = function(level) {
  if (arguments.length > 1) {
    this.boundablesAtLevel2.apply(this, arguments);
    return;
  }

  var boundables = [];
  this.boundablesAtLevel2(level, this.root, boundables);
  return boundables;
};

/**
 * @param {number}
 *          level
 * @param {jsts.index.strtree.AbstractNode}
 *          [top].
 * @param {Array}
 *          [boundables].
 * @return {?Array}
 */
jsts.index.strtree.AbstractSTRtree.prototype.boundablesAtLevel2 = function(
    level, top, boundables) {
  jsts.util.Assert.isTrue(level > -2);
  if (top.getLevel() === level) {
    boundables.add(top);
    return;
  }
  var childBoundables = node.getChildBoundables();
  for (var i = 0; i &lt; childBoundables.length; i++) {
    var boundable = childBoundables[i];
    if (boundable instanceof jsts.index.strtree.AbstractNode) {
      this.boundablesAtLevel(level, boundable, boundables);
    } else {
      jsts.util.Assert.isTrue(boundable instanceof jsts.index.strtree.ItemBoundable);
      if (level === -1) {
        boundables.add(boundable);
      }
    }
  }
  return;
};


/**
 * @return {Comparator}
 */
jsts.index.strtree.AbstractSTRtree.prototype.getComparator = function() {
  throw new jsts.error.AbstractMethodInvocationError();
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="jsts.algorithm.Angle.html">Angle</a></li><li><a href="jsts.algorithm.BoundaryNodeRule.html">BoundaryNodeRule</a></li><li><a href="jsts.algorithm.CentralEndpointIntersector.html">CentralEndpointIntersector</a></li><li><a href="jsts.algorithm.Centroid.html">Centroid</a></li><li><a href="jsts.algorithm.CGAlgorithms.html">CGAlgorithms</a></li><li><a href="jsts.algorithm.ConvexHull.html">ConvexHull</a></li><li><a href="jsts.algorithm.HCoordinate.html">HCoordinate</a></li><li><a href="jsts.algorithm.InteriorPointArea.html">InteriorPointArea</a></li><li><a href="jsts.algorithm.InteriorPointLine.html">InteriorPointLine</a></li><li><a href="jsts.algorithm.InteriorPointPoint.html">InteriorPointPoint</a></li><li><a href="jsts.algorithm.LineIntersector.html">LineIntersector</a></li><li><a href="jsts.algorithm.locate.SimplePointInAreaLocator.html">SimplePointInAreaLocator</a></li><li><a href="jsts.algorithm.MCPointInRing.MCSelecter.html">MCSelecter</a></li><li><a href="jsts.algorithm.MinimumDiameter.html">MinimumDiameter</a></li><li><a href="jsts.algorithm.PointLocator.html">PointLocator</a></li><li><a href="jsts.algorithm.RayCrossingCounter.html">RayCrossingCounter</a></li><li><a href="jsts.algorithm.RobustDeterminant.html">RobustDeterminant</a></li><li><a href="jsts.algorithm.RobustLineIntersector.html">RobustLineIntersector</a></li><li><a href="jsts.algorithm.SafeBisectorFinder.html">SafeBisectorFinder</a></li><li><a href="jsts.error.AbstractMethodInvocationError.html">AbstractMethodInvocationError</a></li><li><a href="jsts.error.IllegalArgumentError.html">IllegalArgumentError</a></li><li><a href="jsts.error.NotImplementedError.html">NotImplementedError</a></li><li><a href="jsts.error.NotRepresentableError.html">NotRepresentableError</a></li><li><a href="jsts.error.TopologyError.html">TopologyError</a></li><li><a href="jsts.geom.Coordinate.html">Coordinate</a></li><li><a href="jsts.geom.CoordinateArrays.html">CoordinateArrays</a></li><li><a href="jsts.geom.CoordinateList.html">CoordinateList</a></li><li><a href="jsts.geom.Dimension.html">Dimension</a></li><li><a href="jsts.geom.Envelope.html">Envelope</a></li><li><a href="jsts.geom.Geometry.html">Geometry</a></li><li><a href="jsts.geom.GeometryCollection.html">GeometryCollection</a></li><li><a href="jsts.geom.GeometryFactory.html">GeometryFactory</a></li><li><a href="jsts.geom.IntersectionMatrix.html">IntersectionMatrix</a></li><li><a href="jsts.geom.LinearRing.html">LinearRing</a></li><li><a href="jsts.geom.LineSegment.html">LineSegment</a></li><li><a href="jsts.geom.LineString.html">LineString</a></li><li><a href="jsts.geom.Location.html">Location</a></li><li><a href="jsts.geom.MultiLineString.html">MultiLineString</a></li><li><a href="jsts.geom.MultiPoint.html">MultiPoint</a></li><li><a href="jsts.geom.MultiPolygon.html">MultiPolygon</a></li><li><a href="jsts.geom.Point.html">Point</a></li><li><a href="jsts.geom.Polygon.html">Polygon</a></li><li><a href="jsts.geom.PrecisionModel.html">PrecisionModel</a></li><li><a href="jsts.geom.Triangle.html">Triangle</a></li><li><a href="jsts.geom.util.GeometryCombiner.html">GeometryCombiner</a></li><li><a href="jsts.geom.util.GeometryExtracter.html">GeometryExtracter</a></li><li><a href="jsts.geom.util.LinearComponentExtracter.html">LinearComponentExtracter</a></li><li><a href="jsts.geom.util.PointExtracter.html">PointExtracter</a></li><li><a href="jsts.geom.util.PolygonExtracter.html">PolygonExtracter</a></li><li><a href="jsts.geomgraph.Depth.html">Depth</a></li><li><a href="jsts.geomgraph.DirectedEdge.html">DirectedEdge</a></li><li><a href="jsts.geomgraph.DirectedEdgeStar.html">DirectedEdgeStar</a></li><li><a href="jsts.geomgraph.Edge.html">Edge</a></li><li><a href="jsts.geomgraph.EdgeEnd.html">EdgeEnd</a></li><li><a href="jsts.geomgraph.EdgeEndStar.html">EdgeEndStar</a></li><li><a href="jsts.geomgraph.EdgeIntersection.html">EdgeIntersection</a></li><li><a href="jsts.geomgraph.EdgeIntersectionList.html">EdgeIntersectionList</a></li><li><a href="jsts.geomgraph.EdgeList.html">EdgeList</a></li><li><a href="jsts.geomgraph.EdgeRing.html">EdgeRing</a></li><li><a href="jsts.geomgraph.GraphComponent.html">GraphComponent</a></li><li><a href="jsts.geomgraph.index.EdgeSetIntersector.html">EdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.MonotoneChainEdge.html">MonotoneChainEdge</a></li><li><a href="jsts.geomgraph.index.MonotoneChainIndexer.html">MonotoneChainIndexer</a></li><li><a href="jsts.geomgraph.index.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleEdgeSetIntersector.html">SimpleEdgeSetIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleMCSweepLineIntersector.html">SimpleMCSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SimpleSweepLineIntersector.html">SimpleSweepLineIntersector</a></li><li><a href="jsts.geomgraph.index.SweepLineEvent.html">SweepLineEvent</a></li><li><a href="jsts.geomgraph.index.SweepLineSegment.html">SweepLineSegment</a></li><li><a href="jsts.geomgraph.Label.html">Label</a></li><li><a href="jsts.geomgraph.Node.html">Node</a></li><li><a href="jsts.geomgraph.NodeFactory.html">NodeFactory</a></li><li><a href="jsts.geomgraph.NodeMap.html">NodeMap</a></li><li><a href="jsts.geomgraph.PlanarGraph.html">PlanarGraph</a></li><li><a href="jsts.geomgraph.Position.html">Position</a></li><li><a href="jsts.geomgraph.Quadrant.html">Quadrant</a></li><li><a href="jsts.geomgraph.TopologyLocation.html">TopologyLocation</a></li><li><a href="jsts.index.ArrayListVisitor.html">ArrayListVisitor</a></li><li><a href="jsts.index.chain.MonotoneChain.html">MonotoneChain</a></li><li><a href="jsts.index.chain.MonotoneChainBuilder.html">MonotoneChainBuilder</a></li><li><a href="jsts.index.chain.MonotoneChainOverlapAction.html">MonotoneChainOverlapAction</a></li><li><a href="jsts.index.chain.MonotoneChainSelectAction.html">MonotoneChainSelectAction</a></li><li><a href="jsts.index.DoubleBits.html">DoubleBits</a></li><li><a href="jsts.index.IntervalSize.html">IntervalSize</a></li><li><a href="jsts.index.kdtree.KdNode.html">KdNode</a></li><li><a href="jsts.index.kdtree.KdTree.html">KdTree</a></li><li><a href="jsts.index.quadtree.Key.html">Key</a></li><li><a href="jsts.index.quadtree.Node.html">Node</a></li><li><a href="jsts.index.quadtree.NodeBase.html">NodeBase</a></li><li><a href="jsts.index.quadtree.Quadtree.html">Quadtree</a></li><li><a href="jsts.index.quadtree.Root.html">Root</a></li><li><a href="jsts.index.strtree.AbstractSTRtree.IntersectsOp.html">IntersectsOp</a></li><li><a href="jsts.index.strtree.Interval.html">Interval</a></li><li><a href="jsts.index.strtree.ItemBoundable.html">ItemBoundable</a></li><li><a href="jsts.index.strtree.SIRtree.html">SIRtree</a></li><li><a href="jsts.index.strtree.STRtree.html">STRtree</a></li><li><a href="jsts.io.GeoJSONReader.html">GeoJSONReader</a></li><li><a href="jsts.io.GeoJSONWriter.html">GeoJSONWriter</a></li><li><a href="jsts.io.WKTReader.html">WKTReader</a></li><li><a href="jsts.io.WKTWriter.html">WKTWriter</a></li><li><a href="jsts.noding.BasicSegmentString.html">BasicSegmentString</a></li><li><a href="jsts.noding.InteriorIntersectionFinder.html">InteriorIntersectionFinder</a></li><li><a href="jsts.noding.IntersectionAdder.html">IntersectionAdder</a></li><li><a href="jsts.noding.MCIndexNoder.html">MCIndexNoder</a></li><li><a href="jsts.noding.NodedSegmentString.html">NodedSegmentString</a></li><li><a href="jsts.noding.Octant.html">Octant</a></li><li><a href="jsts.noding.SegmentNode.html">SegmentNode</a></li><li><a href="jsts.noding.SegmentNodeList.html">SegmentNodeList</a></li><li><a href="jsts.operation.buffer.BufferBuilder.html">BufferBuilder</a></li><li><a href="jsts.operation.buffer.BufferInputLineSimplifier.html">BufferInputLineSimplifier</a></li><li><a href="jsts.operation.buffer.BufferOp.html">BufferOp</a></li><li><a href="jsts.operation.buffer.BufferParameters.html">BufferParameters</a></li><li><a href="jsts.operation.buffer.BufferSubgraph.html">BufferSubgraph</a></li><li><a href="jsts.operation.buffer.OffsetCurveBuilder.html">OffsetCurveBuilder</a></li><li><a href="jsts.operation.buffer.OffsetCurveSetBuilder.html">OffsetCurveSetBuilder</a></li><li><a href="jsts.operation.buffer.OffsetSegmentGenerator.html">OffsetSegmentGenerator</a></li><li><a href="jsts.operation.buffer.OffsetSegmentString.html">OffsetSegmentString</a></li><li><a href="jsts.operation.buffer.RightmostEdgeFinder.html">RightmostEdgeFinder</a></li><li><a href="jsts.operation.buffer.SubgraphDepthLocater.html">SubgraphDepthLocater</a></li><li><a href="jsts.operation.distance.ConnectedElementLocationFilter.html">ConnectedElementLocationFilter</a></li><li><a href="jsts.operation.distance.DistanceOp.html">DistanceOp</a></li><li><a href="jsts.operation.distance.GeometryLocation.html">GeometryLocation</a></li><li><a href="jsts.operation.GeometryGraphOperation.html">GeometryGraphOperation</a></li><li><a href="jsts.operation.IsSimpleOp.html">IsSimpleOp</a></li><li><a href="jsts.operation.IsSimpleOp.EndpointInfo.html">EndpointInfo</a></li><li><a href="jsts.operation.linemerge.EdgeString.html">EdgeString</a></li><li><a href="jsts.operation.linemerge.LineMergeDirectedEdge.html">LineMergeDirectedEdge</a></li><li><a href="jsts.operation.linemerge.LineMergeEdge.html">LineMergeEdge</a></li><li><a href="jsts.operation.linemerge.LineMerger.html">LineMerger</a></li><li><a href="jsts.operation.overlay.MaximalEdgeRing.html">MaximalEdgeRing</a></li><li><a href="jsts.operation.overlay.MinimalEdgeRing.html">MinimalEdgeRing</a></li><li><a href="jsts.operation.overlay.OverlayNodeFactory.html">OverlayNodeFactory</a></li><li><a href="jsts.operation.relate.EdgeEndBuilder.html">EdgeEndBuilder</a></li><li><a href="jsts.operation.relate.EdgeEndBundle.html">EdgeEndBundle</a></li><li><a href="jsts.operation.relate.EdgeEndBundleStar.html">EdgeEndBundleStar</a></li><li><a href="jsts.operation.relate.RelateComputer.html">RelateComputer</a></li><li><a href="jsts.operation.relate.RelateNode.html">RelateNode</a></li><li><a href="jsts.operation.relate.RelateNodeFactory.html">RelateNodeFactory</a></li><li><a href="jsts.operation.relate.RelateNodeGraph.html">RelateNodeGraph</a></li><li><a href="jsts.operation.relate.RelateOp.html">RelateOp</a></li><li><a href="jsts.operation.union.CascadedPolygonUnion.html">CascadedPolygonUnion</a></li><li><a href="jsts.operation.union.PointGeometryUnion.html">PointGeometryUnion</a></li><li><a href="jsts.operation.union.UnaryUnionOp.html">UnaryUnionOp</a></li><li><a href="jsts.operation.union.UnionInteracting.html">UnionInteracting</a></li><li><a href="jsts.operation.valid.ConnectedInteriorTester.html">ConnectedInteriorTester</a></li><li><a href="jsts.operation.valid.IsValidOp.html">IsValidOp</a></li><li><a href="jsts.precision.CommonBits.html">CommonBits</a></li><li><a href="jsts.precision.CommonBitsOp.html">CommonBitsOp</a></li><li><a href="jsts.precision.CommonBitsRemover.html">CommonBitsRemover</a></li><li><a href="jsts.precision.CommonCoordinateFilter.html">CommonCoordinateFilter</a></li><li><a href="jsts.precision.EnhancedPrecisionOp.html">EnhancedPrecisionOp</a></li><li><a href="jsts.precision.Translater.html">Translater</a></li><li><a href="jsts.simplify.DouglasPeuckerLineSimplifier.html">DouglasPeuckerLineSimplifier</a></li><li><a href="jsts.simplify.DouglasPeuckerSimplifier.html">DouglasPeuckerSimplifier</a></li><li><a href="jsts.simplify.DPTransformer.html">DPTransformer</a></li><li><a href="jsts.triangulate.DelaunayTriangulationBuilder.html">DelaunayTriangulationBuilder</a></li><li><a href="jsts.triangulate.quadedge.LastFoundQuadEdgeLocator.html">LastFoundQuadEdgeLocator</a></li><li><a href="jsts.triangulate.quadedge.QuadEdge.html">QuadEdge</a></li><li><a href="jsts.triangulate.quadedge.QuadEdgeSubdivision.html">QuadEdgeSubdivision</a></li><li><a href="jsts.triangulate.quadedge.TrianglePredicate.html">TrianglePredicate</a></li><li><a href="jsts.triangulate.quadedge.Vertex.html">Vertex</a></li><li><a href="jsts.triangulate.VoronoiDiagramBuilder.html">VoronoiDiagramBuilder</a></li><li><a href="jsts.util.Assert.html">Assert</a></li><li><a href="jsts.util.UniqueCoordinateArrayFilter.html">UniqueCoordinateArrayFilter</a></li><li><a href="message.html">message</a></li></ul><h3>Namespaces</h3><ul><li><a href="jsts.html">jsts</a></li><li><a href="jsts.algorithm.html">algorithm</a></li><li><a href="jsts.algorithm.distance.html">distance</a></li><li><a href="jsts.algorithm.locate.html">locate</a></li><li><a href="jsts.densify.html">densify</a></li><li><a href="jsts.error.html">error</a></li><li><a href="jsts.geom.html">geom</a></li><li><a href="jsts.geom.util.html">util</a></li><li><a href="jsts.geomgraph.html">geomgraph</a></li><li><a href="jsts.geomgraph.index.html">index</a></li><li><a href="jsts.index.html">index</a></li><li><a href="jsts.index.bintree.html">bintree</a></li><li><a href="jsts.index.chain.html">chain</a></li><li><a href="jsts.index.kdtree.html">kdtree</a></li><li><a href="jsts.index.quadtree.html">quadtree</a></li><li><a href="jsts.index.strtree.html">strtree</a></li><li><a href="jsts.io.html">io</a></li><li><a href="jsts.noding.html">noding</a></li><li><a href="jsts.noding.snapround.html">snapround</a></li><li><a href="jsts.operation.html">operation</a></li><li><a href="jsts.operation.buffer.html">buffer</a></li><li><a href="jsts.operation.distance.html">distance</a></li><li><a href="jsts.operation.linemerge.html">linemerge</a></li><li><a href="jsts.operation.overlay.html">overlay</a></li><li><a href="jsts.operation.overlay.snap.html">snap</a></li><li><a href="jsts.operation.polygonize.html">polygonize</a></li><li><a href="jsts.operation.predicate.html">predicate</a></li><li><a href="jsts.operation.relate.html">relate</a></li><li><a href="jsts.operation.union.html">union</a></li><li><a href="jsts.operation.valid.html">valid</a></li><li><a href="jsts.planargraph.html">planargraph</a></li><li><a href="jsts.precision.html">precision</a></li><li><a href="jsts.simplify.html">simplify</a></li><li><a href="jsts.triangulate.html">triangulate</a></li><li><a href="jsts.triangulate.quadedge.html">quadedge</a></li><li><a href="jsts.util.html">util</a></li></ul><h3>Interfaces</h3><ul><li><a href="jsts.geom.CoordinateFilter.html">CoordinateFilter</a></li><li><a href="jsts.index.ItemVisitor.html">ItemVisitor</a></li><li><a href="jsts.index.SpatialIndex.html">SpatialIndex</a></li><li><a href="jsts.index.strtree.AbstractNode.html">AbstractNode</a></li><li><a href="jsts.index.strtree.Boundable.html">Boundable</a></li><li><a href="jsts.noding.NodableSegmentString.html">NodableSegmentString</a></li><li><a href="jsts.noding.Noder.html">Noder</a></li><li><a href="jsts.noding.SegmentIntersector.html">SegmentIntersector</a></li><li><a href="jsts.noding.SegmentString.html">SegmentString</a></li><li><a href="jsts.noding.SinglePassNoder.html">SinglePassNoder</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sat Nov 21 2015 16:13:04 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
